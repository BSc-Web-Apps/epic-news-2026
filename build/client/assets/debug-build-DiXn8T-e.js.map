{"version":3,"file":"debug-build-DiXn8T-e.js","sources":["../../../node_modules/@sentry/core/build/esm/debug-build.js","../../../node_modules/@sentry/core/build/esm/utils/worldwide.js","../../../node_modules/@sentry/core/build/esm/utils/version.js","../../../node_modules/@sentry/core/build/esm/carrier.js","../../../node_modules/@sentry/core/build/esm/utils/logger.js","../../../node_modules/@sentry/core/build/esm/utils/stacktrace.js","../../../node_modules/@sentry/core/build/esm/utils/is.js","../../../node_modules/@sentry/core/build/esm/utils/browser.js","../../../node_modules/@sentry/core/build/esm/utils/string.js","../../../node_modules/@sentry/core/build/esm/utils/object.js","../../../node_modules/@sentry/core/build/esm/utils/misc.js","../../../node_modules/@sentry/core/build/esm/utils/time.js","../../../node_modules/@sentry/core/build/esm/session.js","../../../node_modules/@sentry/core/build/esm/utils/merge.js","../../../node_modules/@sentry/core/build/esm/utils/propagationContext.js","../../../node_modules/@sentry/core/build/esm/utils/spanOnScope.js","../../../node_modules/@sentry/core/build/esm/scope.js","../../../node_modules/@sentry/core/build/esm/defaultScopes.js","../../../node_modules/@sentry/core/build/esm/asyncContext/stackStrategy.js","../../../node_modules/@sentry/core/build/esm/asyncContext/index.js","../../../node_modules/@sentry/core/build/esm/currentScopes.js","../../../node_modules/@sentry/core/build/esm/semanticAttributes.js","../../../node_modules/@sentry/core/build/esm/tracing/spanstatus.js","../../../node_modules/@sentry/core/build/esm/tracing/utils.js","../../../node_modules/@sentry/core/build/esm/utils/baggage.js","../../../node_modules/@sentry/core/build/esm/utils/spanUtils.js","../../../node_modules/@sentry/core/build/esm/utils/hasSpansEnabled.js","../../../node_modules/@sentry/core/build/esm/constants.js","../../../node_modules/@sentry/core/build/esm/utils/dsn.js","../../../node_modules/@sentry/core/build/esm/tracing/dynamicSamplingContext.js","../../../node_modules/@sentry/core/build/esm/utils/normalize.js","../../../node_modules/@sentry/core/build/esm/utils/syncpromise.js","../../../node_modules/@sentry/core/build/esm/eventProcessors.js","../../../node_modules/@sentry/core/build/esm/utils/applyScopeDataToEvent.js","../../../node_modules/@sentry/core/build/esm/utils/debug-ids.js","../../../node_modules/@sentry/core/build/esm/utils/prepareEvent.js","../../../node_modules/@sentry/core/build/esm/exports.js"],"sourcesContent":["/**\n * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.\n *\n * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.\n */\nconst DEBUG_BUILD = (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__);\n\nexport { DEBUG_BUILD };\n//# sourceMappingURL=debug-build.js.map\n","/** Internal global with common properties and Sentry extensions  */\n\n/** Get's the global object for the current JavaScript runtime */\nconst GLOBAL_OBJ = globalThis ;\n\nexport { GLOBAL_OBJ };\n//# sourceMappingURL=worldwide.js.map\n","// This is a magic string replaced by rollup\n\nconst SDK_VERSION = \"9.32.0\" ;\n\nexport { SDK_VERSION };\n//# sourceMappingURL=version.js.map\n","import { SDK_VERSION } from './utils/version.js';\nimport { GLOBAL_OBJ } from './utils/worldwide.js';\n\n/**\n * An object that contains globally accessible properties and maintains a scope stack.\n * @hidden\n */\n\n/**\n * Returns the global shim registry.\n *\n * FIXME: This function is problematic, because despite always returning a valid Carrier,\n * it has an optional `__SENTRY__` property, which then in turn requires us to always perform an unnecessary check\n * at the call-site. We always access the carrier through this function, so we can guarantee that `__SENTRY__` is there.\n **/\nfunction getMainCarrier() {\n  // This ensures a Sentry carrier exists\n  getSentryCarrier(GLOBAL_OBJ);\n  return GLOBAL_OBJ;\n}\n\n/** Will either get the existing sentry carrier, or create a new one. */\nfunction getSentryCarrier(carrier) {\n  const __SENTRY__ = (carrier.__SENTRY__ = carrier.__SENTRY__ || {});\n\n  // For now: First SDK that sets the .version property wins\n  __SENTRY__.version = __SENTRY__.version || SDK_VERSION;\n\n  // Intentionally populating and returning the version of \"this\" SDK instance\n  // rather than what's set in .version so that \"this\" SDK always gets its carrier\n  return (__SENTRY__[SDK_VERSION] = __SENTRY__[SDK_VERSION] || {});\n}\n\n/**\n * Returns a global singleton contained in the global `__SENTRY__[]` object.\n *\n * If the singleton doesn't already exist in `__SENTRY__`, it will be created using the given factory\n * function and added to the `__SENTRY__` object.\n *\n * @param name name of the global singleton on __SENTRY__\n * @param creator creator Factory function to create the singleton if it doesn't already exist on `__SENTRY__`\n * @param obj (Optional) The global object on which to look for `__SENTRY__`, if not `GLOBAL_OBJ`'s return value\n * @returns the singleton\n */\nfunction getGlobalSingleton(\n  name,\n  creator,\n  obj = GLOBAL_OBJ,\n) {\n  const __SENTRY__ = (obj.__SENTRY__ = obj.__SENTRY__ || {});\n  const carrier = (__SENTRY__[SDK_VERSION] = __SENTRY__[SDK_VERSION] || {});\n  // Note: We do not want to set `carrier.version` here, as this may be called before any `init` is called, e.g. for the default scopes\n  return carrier[name] || (carrier[name] = creator());\n}\n\nexport { getGlobalSingleton, getMainCarrier, getSentryCarrier };\n//# sourceMappingURL=carrier.js.map\n","import { getGlobalSingleton } from '../carrier.js';\nimport { DEBUG_BUILD } from '../debug-build.js';\nimport { GLOBAL_OBJ } from './worldwide.js';\n\n/** Prefix for logging strings */\nconst PREFIX = 'Sentry Logger ';\n\nconst CONSOLE_LEVELS = [\n  'debug',\n  'info',\n  'warn',\n  'error',\n  'log',\n  'assert',\n  'trace',\n] ;\n\n/** This may be mutated by the console instrumentation. */\nconst originalConsoleMethods\n\n = {};\n\n/** A Sentry Logger instance. */\n\n/**\n * Temporarily disable sentry console instrumentations.\n *\n * @param callback The function to run against the original `console` messages\n * @returns The results of the callback\n */\nfunction consoleSandbox(callback) {\n  if (!('console' in GLOBAL_OBJ)) {\n    return callback();\n  }\n\n  const console = GLOBAL_OBJ.console ;\n  const wrappedFuncs = {};\n\n  const wrappedLevels = Object.keys(originalConsoleMethods) ;\n\n  // Restore all wrapped console methods\n  wrappedLevels.forEach(level => {\n    const originalConsoleMethod = originalConsoleMethods[level] ;\n    wrappedFuncs[level] = console[level] ;\n    console[level] = originalConsoleMethod;\n  });\n\n  try {\n    return callback();\n  } finally {\n    // Revert restoration to wrapped state\n    wrappedLevels.forEach(level => {\n      console[level] = wrappedFuncs[level] ;\n    });\n  }\n}\n\nfunction makeLogger() {\n  let enabled = false;\n  const logger = {\n    enable: () => {\n      enabled = true;\n    },\n    disable: () => {\n      enabled = false;\n    },\n    isEnabled: () => enabled,\n  };\n\n  if (DEBUG_BUILD) {\n    CONSOLE_LEVELS.forEach(name => {\n      logger[name] = (...args) => {\n        if (enabled) {\n          consoleSandbox(() => {\n            GLOBAL_OBJ.console[name](`${PREFIX}[${name}]:`, ...args);\n          });\n        }\n      };\n    });\n  } else {\n    CONSOLE_LEVELS.forEach(name => {\n      logger[name] = () => undefined;\n    });\n  }\n\n  return logger ;\n}\n\n/**\n * This is a logger singleton which either logs things or no-ops if logging is not enabled.\n * The logger is a singleton on the carrier, to ensure that a consistent logger is used throughout the SDK.\n */\nconst logger = getGlobalSingleton('logger', makeLogger);\n\nexport { CONSOLE_LEVELS, consoleSandbox, logger, originalConsoleMethods };\n//# sourceMappingURL=logger.js.map\n","const STACKTRACE_FRAME_LIMIT = 50;\nconst UNKNOWN_FUNCTION = '?';\n// Used to sanitize webpack (error: *) wrapped stack errors\nconst WEBPACK_ERROR_REGEXP = /\\(error: (.*)\\)/;\nconst STRIP_FRAME_REGEXP = /captureMessage|captureException/;\n\n/**\n * Creates a stack parser with the supplied line parsers\n *\n * StackFrames are returned in the correct order for Sentry Exception\n * frames and with Sentry SDK internal frames removed from the top and bottom\n *\n */\nfunction createStackParser(...parsers) {\n  const sortedParsers = parsers.sort((a, b) => a[0] - b[0]).map(p => p[1]);\n\n  return (stack, skipFirstLines = 0, framesToPop = 0) => {\n    const frames = [];\n    const lines = stack.split('\\n');\n\n    for (let i = skipFirstLines; i < lines.length; i++) {\n      const line = lines[i] ;\n      // Ignore lines over 1kb as they are unlikely to be stack frames.\n      // Many of the regular expressions use backtracking which results in run time that increases exponentially with\n      // input size. Huge strings can result in hangs/Denial of Service:\n      // https://github.com/getsentry/sentry-javascript/issues/2286\n      if (line.length > 1024) {\n        continue;\n      }\n\n      // https://github.com/getsentry/sentry-javascript/issues/5459\n      // Remove webpack (error: *) wrappers\n      const cleanedLine = WEBPACK_ERROR_REGEXP.test(line) ? line.replace(WEBPACK_ERROR_REGEXP, '$1') : line;\n\n      // https://github.com/getsentry/sentry-javascript/issues/7813\n      // Skip Error: lines\n      if (cleanedLine.match(/\\S*Error: /)) {\n        continue;\n      }\n\n      for (const parser of sortedParsers) {\n        const frame = parser(cleanedLine);\n\n        if (frame) {\n          frames.push(frame);\n          break;\n        }\n      }\n\n      if (frames.length >= STACKTRACE_FRAME_LIMIT + framesToPop) {\n        break;\n      }\n    }\n\n    return stripSentryFramesAndReverse(frames.slice(framesToPop));\n  };\n}\n\n/**\n * Gets a stack parser implementation from Options.stackParser\n * @see Options\n *\n * If options contains an array of line parsers, it is converted into a parser\n */\nfunction stackParserFromStackParserOptions(stackParser) {\n  if (Array.isArray(stackParser)) {\n    return createStackParser(...stackParser);\n  }\n  return stackParser;\n}\n\n/**\n * Removes Sentry frames from the top and bottom of the stack if present and enforces a limit of max number of frames.\n * Assumes stack input is ordered from top to bottom and returns the reverse representation so call site of the\n * function that caused the crash is the last frame in the array.\n * @hidden\n */\nfunction stripSentryFramesAndReverse(stack) {\n  if (!stack.length) {\n    return [];\n  }\n\n  const localStack = Array.from(stack);\n\n  // If stack starts with one of our API calls, remove it (starts, meaning it's the top of the stack - aka last call)\n  if (/sentryWrapped/.test(getLastStackFrame(localStack).function || '')) {\n    localStack.pop();\n  }\n\n  // Reversing in the middle of the procedure allows us to just pop the values off the stack\n  localStack.reverse();\n\n  // If stack ends with one of our internal API calls, remove it (ends, meaning it's the bottom of the stack - aka top-most call)\n  if (STRIP_FRAME_REGEXP.test(getLastStackFrame(localStack).function || '')) {\n    localStack.pop();\n\n    // When using synthetic events, we will have a 2 levels deep stack, as `new Error('Sentry syntheticException')`\n    // is produced within the scope itself, making it:\n    //\n    //   Sentry.captureException()\n    //   scope.captureException()\n    //\n    // instead of just the top `Sentry` call itself.\n    // This forces us to possibly strip an additional frame in the exact same was as above.\n    if (STRIP_FRAME_REGEXP.test(getLastStackFrame(localStack).function || '')) {\n      localStack.pop();\n    }\n  }\n\n  return localStack.slice(0, STACKTRACE_FRAME_LIMIT).map(frame => ({\n    ...frame,\n    filename: frame.filename || getLastStackFrame(localStack).filename,\n    function: frame.function || UNKNOWN_FUNCTION,\n  }));\n}\n\nfunction getLastStackFrame(arr) {\n  return arr[arr.length - 1] || {};\n}\n\nconst defaultFunctionName = '<anonymous>';\n\n/**\n * Safely extract function name from itself\n */\nfunction getFunctionName(fn) {\n  try {\n    if (!fn || typeof fn !== 'function') {\n      return defaultFunctionName;\n    }\n    return fn.name || defaultFunctionName;\n  } catch (e) {\n    // Just accessing custom props in some Selenium environments\n    // can cause a \"Permission denied\" exception (see raven-js#495).\n    return defaultFunctionName;\n  }\n}\n\n/**\n * Get's stack frames from an event without needing to check for undefined properties.\n */\nfunction getFramesFromEvent(event) {\n  const exception = event.exception;\n\n  if (exception) {\n    const frames = [];\n    try {\n      // @ts-expect-error Object could be undefined\n      exception.values.forEach(value => {\n        // @ts-expect-error Value could be undefined\n        if (value.stacktrace.frames) {\n          // @ts-expect-error Value could be undefined\n          frames.push(...value.stacktrace.frames);\n        }\n      });\n      return frames;\n    } catch (_oO) {\n      return undefined;\n    }\n  }\n  return undefined;\n}\n\nexport { UNKNOWN_FUNCTION, createStackParser, getFramesFromEvent, getFunctionName, stackParserFromStackParserOptions, stripSentryFramesAndReverse };\n//# sourceMappingURL=stacktrace.js.map\n","// eslint-disable-next-line @typescript-eslint/unbound-method\nconst objectToString = Object.prototype.toString;\n\n/**\n * Checks whether given value's type is one of a few Error or Error-like\n * {@link isError}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isError(wat) {\n  switch (objectToString.call(wat)) {\n    case '[object Error]':\n    case '[object Exception]':\n    case '[object DOMException]':\n    case '[object WebAssembly.Exception]':\n      return true;\n    default:\n      return isInstanceOf(wat, Error);\n  }\n}\n/**\n * Checks whether given value is an instance of the given built-in class.\n *\n * @param wat The value to be checked\n * @param className\n * @returns A boolean representing the result.\n */\nfunction isBuiltin(wat, className) {\n  return objectToString.call(wat) === `[object ${className}]`;\n}\n\n/**\n * Checks whether given value's type is ErrorEvent\n * {@link isErrorEvent}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isErrorEvent(wat) {\n  return isBuiltin(wat, 'ErrorEvent');\n}\n\n/**\n * Checks whether given value's type is DOMError\n * {@link isDOMError}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isDOMError(wat) {\n  return isBuiltin(wat, 'DOMError');\n}\n\n/**\n * Checks whether given value's type is DOMException\n * {@link isDOMException}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isDOMException(wat) {\n  return isBuiltin(wat, 'DOMException');\n}\n\n/**\n * Checks whether given value's type is a string\n * {@link isString}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isString(wat) {\n  return isBuiltin(wat, 'String');\n}\n\n/**\n * Checks whether given string is parameterized\n * {@link isParameterizedString}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isParameterizedString(wat) {\n  return (\n    typeof wat === 'object' &&\n    wat !== null &&\n    '__sentry_template_string__' in wat &&\n    '__sentry_template_values__' in wat\n  );\n}\n\n/**\n * Checks whether given value is a primitive (undefined, null, number, boolean, string, bigint, symbol)\n * {@link isPrimitive}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isPrimitive(wat) {\n  return wat === null || isParameterizedString(wat) || (typeof wat !== 'object' && typeof wat !== 'function');\n}\n\n/**\n * Checks whether given value's type is an object literal, or a class instance.\n * {@link isPlainObject}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isPlainObject(wat) {\n  return isBuiltin(wat, 'Object');\n}\n\n/**\n * Checks whether given value's type is an Event instance\n * {@link isEvent}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isEvent(wat) {\n  return typeof Event !== 'undefined' && isInstanceOf(wat, Event);\n}\n\n/**\n * Checks whether given value's type is an Element instance\n * {@link isElement}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isElement(wat) {\n  return typeof Element !== 'undefined' && isInstanceOf(wat, Element);\n}\n\n/**\n * Checks whether given value's type is an regexp\n * {@link isRegExp}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isRegExp(wat) {\n  return isBuiltin(wat, 'RegExp');\n}\n\n/**\n * Checks whether given value has a then function.\n * @param wat A value to be checked.\n */\nfunction isThenable(wat) {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  return Boolean(wat?.then && typeof wat.then === 'function');\n}\n\n/**\n * Checks whether given value's type is a SyntheticEvent\n * {@link isSyntheticEvent}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isSyntheticEvent(wat) {\n  return isPlainObject(wat) && 'nativeEvent' in wat && 'preventDefault' in wat && 'stopPropagation' in wat;\n}\n\n/**\n * Checks whether given value's type is an instance of provided constructor.\n * {@link isInstanceOf}.\n *\n * @param wat A value to be checked.\n * @param base A constructor to be used in a check.\n * @returns A boolean representing the result.\n */\nfunction isInstanceOf(wat, base) {\n  try {\n    return wat instanceof base;\n  } catch (_e) {\n    return false;\n  }\n}\n\n/**\n * Checks whether given value's type is a Vue ViewModel.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isVueViewModel(wat) {\n  // Not using Object.prototype.toString because in Vue 3 it would read the instance's Symbol(Symbol.toStringTag) property.\n  return !!(typeof wat === 'object' && wat !== null && ((wat ).__isVue || (wat )._isVue));\n}\n\n/**\n * Checks whether the given parameter is a Standard Web API Request instance.\n *\n * Returns false if Request is not available in the current runtime.\n */\nfunction isRequest(request) {\n  return typeof Request !== 'undefined' && isInstanceOf(request, Request);\n}\n\nexport { isDOMError, isDOMException, isElement, isError, isErrorEvent, isEvent, isInstanceOf, isParameterizedString, isPlainObject, isPrimitive, isRegExp, isRequest, isString, isSyntheticEvent, isThenable, isVueViewModel };\n//# sourceMappingURL=is.js.map\n","import { isString } from './is.js';\nimport { GLOBAL_OBJ } from './worldwide.js';\n\nconst WINDOW = GLOBAL_OBJ ;\n\nconst DEFAULT_MAX_STRING_LENGTH = 80;\n\n/**\n * Given a child DOM element, returns a query-selector statement describing that\n * and its ancestors\n * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]\n * @returns generated DOM path\n */\nfunction htmlTreeAsString(\n  elem,\n  options = {},\n) {\n  if (!elem) {\n    return '<unknown>';\n  }\n\n  // try/catch both:\n  // - accessing event.target (see getsentry/raven-js#838, #768)\n  // - `htmlTreeAsString` because it's complex, and just accessing the DOM incorrectly\n  // - can throw an exception in some circumstances.\n  try {\n    let currentElem = elem ;\n    const MAX_TRAVERSE_HEIGHT = 5;\n    const out = [];\n    let height = 0;\n    let len = 0;\n    const separator = ' > ';\n    const sepLength = separator.length;\n    let nextStr;\n    const keyAttrs = Array.isArray(options) ? options : options.keyAttrs;\n    const maxStringLength = (!Array.isArray(options) && options.maxStringLength) || DEFAULT_MAX_STRING_LENGTH;\n\n    while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {\n      nextStr = _htmlElementAsString(currentElem, keyAttrs);\n      // bail out if\n      // - nextStr is the 'html' element\n      // - the length of the string that would be created exceeds maxStringLength\n      //   (ignore this limit if we are on the first iteration)\n      if (nextStr === 'html' || (height > 1 && len + out.length * sepLength + nextStr.length >= maxStringLength)) {\n        break;\n      }\n\n      out.push(nextStr);\n\n      len += nextStr.length;\n      currentElem = currentElem.parentNode;\n    }\n\n    return out.reverse().join(separator);\n  } catch (_oO) {\n    return '<unknown>';\n  }\n}\n\n/**\n * Returns a simple, query-selector representation of a DOM element\n * e.g. [HTMLElement] => input#foo.btn[name=baz]\n * @returns generated DOM path\n */\nfunction _htmlElementAsString(el, keyAttrs) {\n  const elem = el\n\n;\n\n  const out = [];\n\n  if (!elem?.tagName) {\n    return '';\n  }\n\n  // @ts-expect-error WINDOW has HTMLElement\n  if (WINDOW.HTMLElement) {\n    // If using the component name annotation plugin, this value may be available on the DOM node\n    if (elem instanceof HTMLElement && elem.dataset) {\n      if (elem.dataset['sentryComponent']) {\n        return elem.dataset['sentryComponent'];\n      }\n      if (elem.dataset['sentryElement']) {\n        return elem.dataset['sentryElement'];\n      }\n    }\n  }\n\n  out.push(elem.tagName.toLowerCase());\n\n  // Pairs of attribute keys defined in `serializeAttribute` and their values on element.\n  const keyAttrPairs = keyAttrs?.length\n    ? keyAttrs.filter(keyAttr => elem.getAttribute(keyAttr)).map(keyAttr => [keyAttr, elem.getAttribute(keyAttr)])\n    : null;\n\n  if (keyAttrPairs?.length) {\n    keyAttrPairs.forEach(keyAttrPair => {\n      out.push(`[${keyAttrPair[0]}=\"${keyAttrPair[1]}\"]`);\n    });\n  } else {\n    if (elem.id) {\n      out.push(`#${elem.id}`);\n    }\n\n    const className = elem.className;\n    if (className && isString(className)) {\n      const classes = className.split(/\\s+/);\n      for (const c of classes) {\n        out.push(`.${c}`);\n      }\n    }\n  }\n  const allowedAttrs = ['aria-label', 'type', 'name', 'title', 'alt'];\n  for (const k of allowedAttrs) {\n    const attr = elem.getAttribute(k);\n    if (attr) {\n      out.push(`[${k}=\"${attr}\"]`);\n    }\n  }\n\n  return out.join('');\n}\n\n/**\n * A safe form of location.href\n */\nfunction getLocationHref() {\n  try {\n    return WINDOW.document.location.href;\n  } catch (oO) {\n    return '';\n  }\n}\n\n/**\n * Given a DOM element, traverses up the tree until it finds the first ancestor node\n * that has the `data-sentry-component` or `data-sentry-element` attribute with `data-sentry-component` taking\n * precedence. This attribute is added at build-time by projects that have the component name annotation plugin installed.\n *\n * @returns a string representation of the component for the provided DOM element, or `null` if not found\n */\nfunction getComponentName(elem) {\n  // @ts-expect-error WINDOW has HTMLElement\n  if (!WINDOW.HTMLElement) {\n    return null;\n  }\n\n  let currentElem = elem ;\n  const MAX_TRAVERSE_HEIGHT = 5;\n  for (let i = 0; i < MAX_TRAVERSE_HEIGHT; i++) {\n    if (!currentElem) {\n      return null;\n    }\n\n    if (currentElem instanceof HTMLElement) {\n      if (currentElem.dataset['sentryComponent']) {\n        return currentElem.dataset['sentryComponent'];\n      }\n      if (currentElem.dataset['sentryElement']) {\n        return currentElem.dataset['sentryElement'];\n      }\n    }\n\n    currentElem = currentElem.parentNode;\n  }\n\n  return null;\n}\n\nexport { getComponentName, getLocationHref, htmlTreeAsString };\n//# sourceMappingURL=browser.js.map\n","import { isString, isRegExp, isVueViewModel } from './is.js';\n\n/**\n * Truncates given string to the maximum characters count\n *\n * @param str An object that contains serializable values\n * @param max Maximum number of characters in truncated string (0 = unlimited)\n * @returns string Encoded\n */\nfunction truncate(str, max = 0) {\n  if (typeof str !== 'string' || max === 0) {\n    return str;\n  }\n  return str.length <= max ? str : `${str.slice(0, max)}...`;\n}\n\n/**\n * This is basically just `trim_line` from\n * https://github.com/getsentry/sentry/blob/master/src/sentry/lang/javascript/processor.py#L67\n *\n * @param str An object that contains serializable values\n * @param max Maximum number of characters in truncated string\n * @returns string Encoded\n */\nfunction snipLine(line, colno) {\n  let newLine = line;\n  const lineLength = newLine.length;\n  if (lineLength <= 150) {\n    return newLine;\n  }\n  if (colno > lineLength) {\n    // eslint-disable-next-line no-param-reassign\n    colno = lineLength;\n  }\n\n  let start = Math.max(colno - 60, 0);\n  if (start < 5) {\n    start = 0;\n  }\n\n  let end = Math.min(start + 140, lineLength);\n  if (end > lineLength - 5) {\n    end = lineLength;\n  }\n  if (end === lineLength) {\n    start = Math.max(end - 140, 0);\n  }\n\n  newLine = newLine.slice(start, end);\n  if (start > 0) {\n    newLine = `'{snip} ${newLine}`;\n  }\n  if (end < lineLength) {\n    newLine += ' {snip}';\n  }\n\n  return newLine;\n}\n\n/**\n * Join values in array\n * @param input array of values to be joined together\n * @param delimiter string to be placed in-between values\n * @returns Joined values\n */\nfunction safeJoin(input, delimiter) {\n  if (!Array.isArray(input)) {\n    return '';\n  }\n\n  const output = [];\n  // eslint-disable-next-line @typescript-eslint/prefer-for-of\n  for (let i = 0; i < input.length; i++) {\n    const value = input[i];\n    try {\n      // This is a hack to fix a Vue3-specific bug that causes an infinite loop of\n      // console warnings. This happens when a Vue template is rendered with\n      // an undeclared variable, which we try to stringify, ultimately causing\n      // Vue to issue another warning which repeats indefinitely.\n      // see: https://github.com/getsentry/sentry-javascript/pull/8981\n      if (isVueViewModel(value)) {\n        output.push('[VueViewModel]');\n      } else {\n        output.push(String(value));\n      }\n    } catch (e) {\n      output.push('[value cannot be serialized]');\n    }\n  }\n\n  return output.join(delimiter);\n}\n\n/**\n * Checks if the given value matches a regex or string\n *\n * @param value The string to test\n * @param pattern Either a regex or a string against which `value` will be matched\n * @param requireExactStringMatch If true, `value` must match `pattern` exactly. If false, `value` will match\n * `pattern` if it contains `pattern`. Only applies to string-type patterns.\n */\nfunction isMatchingPattern(\n  value,\n  pattern,\n  requireExactStringMatch = false,\n) {\n  if (!isString(value)) {\n    return false;\n  }\n\n  if (isRegExp(pattern)) {\n    return pattern.test(value);\n  }\n  if (isString(pattern)) {\n    return requireExactStringMatch ? value === pattern : value.includes(pattern);\n  }\n\n  return false;\n}\n\n/**\n * Test the given string against an array of strings and regexes. By default, string matching is done on a\n * substring-inclusion basis rather than a strict equality basis\n *\n * @param testString The string to test\n * @param patterns The patterns against which to test the string\n * @param requireExactStringMatch If true, `testString` must match one of the given string patterns exactly in order to\n * count. If false, `testString` will match a string pattern if it contains that pattern.\n * @returns\n */\nfunction stringMatchesSomePattern(\n  testString,\n  patterns = [],\n  requireExactStringMatch = false,\n) {\n  return patterns.some(pattern => isMatchingPattern(testString, pattern, requireExactStringMatch));\n}\n\nexport { isMatchingPattern, safeJoin, snipLine, stringMatchesSomePattern, truncate };\n//# sourceMappingURL=string.js.map\n","import { DEBUG_BUILD } from '../debug-build.js';\nimport { htmlTreeAsString } from './browser.js';\nimport { isError, isEvent, isInstanceOf, isPrimitive, isElement } from './is.js';\nimport { logger } from './logger.js';\nimport { truncate } from './string.js';\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/**\n * Replace a method in an object with a wrapped version of itself.\n *\n * If the method on the passed object is not a function, the wrapper will not be applied.\n *\n * @param source An object that contains a method to be wrapped.\n * @param name The name of the method to be wrapped.\n * @param replacementFactory A higher-order function that takes the original version of the given method and returns a\n * wrapped version. Note: The function returned by `replacementFactory` needs to be a non-arrow function, in order to\n * preserve the correct value of `this`, and the original method must be called using `origMethod.call(this, <other\n * args>)` or `origMethod.apply(this, [<other args>])` (rather than being called directly), again to preserve `this`.\n * @returns void\n */\nfunction fill(source, name, replacementFactory) {\n  if (!(name in source)) {\n    return;\n  }\n\n  // explicitly casting to unknown because we don't know the type of the method initially at all\n  const original = source[name] ;\n\n  if (typeof original !== 'function') {\n    return;\n  }\n\n  const wrapped = replacementFactory(original) ;\n\n  // Make sure it's a function first, as we need to attach an empty prototype for `defineProperties` to work\n  // otherwise it'll throw \"TypeError: Object.defineProperties called on non-object\"\n  if (typeof wrapped === 'function') {\n    markFunctionWrapped(wrapped, original);\n  }\n\n  try {\n    source[name] = wrapped;\n  } catch {\n    DEBUG_BUILD && logger.log(`Failed to replace method \"${name}\" in object`, source);\n  }\n}\n\n/**\n * Defines a non-enumerable property on the given object.\n *\n * @param obj The object on which to set the property\n * @param name The name of the property to be set\n * @param value The value to which to set the property\n */\nfunction addNonEnumerableProperty(obj, name, value) {\n  try {\n    Object.defineProperty(obj, name, {\n      // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it\n      value: value,\n      writable: true,\n      configurable: true,\n    });\n  } catch (o_O) {\n    DEBUG_BUILD && logger.log(`Failed to add non-enumerable property \"${name}\" to object`, obj);\n  }\n}\n\n/**\n * Remembers the original function on the wrapped function and\n * patches up the prototype.\n *\n * @param wrapped the wrapper function\n * @param original the original function that gets wrapped\n */\nfunction markFunctionWrapped(wrapped, original) {\n  try {\n    const proto = original.prototype || {};\n    wrapped.prototype = original.prototype = proto;\n    addNonEnumerableProperty(wrapped, '__sentry_original__', original);\n  } catch (o_O) {} // eslint-disable-line no-empty\n}\n\n/**\n * This extracts the original function if available.  See\n * `markFunctionWrapped` for more information.\n *\n * @param func the function to unwrap\n * @returns the unwrapped version of the function if available.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction getOriginalFunction(func) {\n  return func.__sentry_original__;\n}\n\n/**\n * Transforms any `Error` or `Event` into a plain object with all of their enumerable properties, and some of their\n * non-enumerable properties attached.\n *\n * @param value Initial source that we have to transform in order for it to be usable by the serializer\n * @returns An Event or Error turned into an object - or the value argument itself, when value is neither an Event nor\n *  an Error.\n */\nfunction convertToPlainObject(value)\n\n {\n  if (isError(value)) {\n    return {\n      message: value.message,\n      name: value.name,\n      stack: value.stack,\n      ...getOwnProperties(value),\n    };\n  } else if (isEvent(value)) {\n    const newObj\n\n = {\n      type: value.type,\n      target: serializeEventTarget(value.target),\n      currentTarget: serializeEventTarget(value.currentTarget),\n      ...getOwnProperties(value),\n    };\n\n    if (typeof CustomEvent !== 'undefined' && isInstanceOf(value, CustomEvent)) {\n      newObj.detail = value.detail;\n    }\n\n    return newObj;\n  } else {\n    return value;\n  }\n}\n\n/** Creates a string representation of the target of an `Event` object */\nfunction serializeEventTarget(target) {\n  try {\n    return isElement(target) ? htmlTreeAsString(target) : Object.prototype.toString.call(target);\n  } catch (_oO) {\n    return '<unknown>';\n  }\n}\n\n/** Filters out all but an object's own properties */\nfunction getOwnProperties(obj) {\n  if (typeof obj === 'object' && obj !== null) {\n    const extractedProps = {};\n    for (const property in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, property)) {\n        extractedProps[property] = (obj )[property];\n      }\n    }\n    return extractedProps;\n  } else {\n    return {};\n  }\n}\n\n/**\n * Given any captured exception, extract its keys and create a sorted\n * and truncated list that will be used inside the event message.\n * eg. `Non-error exception captured with keys: foo, bar, baz`\n */\nfunction extractExceptionKeysForMessage(exception, maxLength = 40) {\n  const keys = Object.keys(convertToPlainObject(exception));\n  keys.sort();\n\n  const firstKey = keys[0];\n\n  if (!firstKey) {\n    return '[object has no keys]';\n  }\n\n  if (firstKey.length >= maxLength) {\n    return truncate(firstKey, maxLength);\n  }\n\n  for (let includedKeys = keys.length; includedKeys > 0; includedKeys--) {\n    const serialized = keys.slice(0, includedKeys).join(', ');\n    if (serialized.length > maxLength) {\n      continue;\n    }\n    if (includedKeys === keys.length) {\n      return serialized;\n    }\n    return truncate(serialized, maxLength);\n  }\n\n  return '';\n}\n\n/**\n * Given any object, return a new object having removed all fields whose value was `undefined`.\n * Works recursively on objects and arrays.\n *\n * Attention: This function keeps circular references in the returned object.\n *\n * @deprecated This function is no longer used by the SDK and will be removed in a future major version.\n */\nfunction dropUndefinedKeys(inputValue) {\n  // This map keeps track of what already visited nodes map to.\n  // Our Set - based memoBuilder doesn't work here because we want to the output object to have the same circular\n  // references as the input object.\n  const memoizationMap = new Map();\n\n  // This function just proxies `_dropUndefinedKeys` to keep the `memoBuilder` out of this function's API\n  return _dropUndefinedKeys(inputValue, memoizationMap);\n}\n\nfunction _dropUndefinedKeys(inputValue, memoizationMap) {\n  // Early return for primitive values\n  if (inputValue === null || typeof inputValue !== 'object') {\n    return inputValue;\n  }\n\n  // Check memo map first for all object types\n  const memoVal = memoizationMap.get(inputValue);\n  if (memoVal !== undefined) {\n    return memoVal ;\n  }\n\n  // handle arrays\n  if (Array.isArray(inputValue)) {\n    const returnValue = [];\n    // Store mapping to handle circular references\n    memoizationMap.set(inputValue, returnValue);\n\n    inputValue.forEach(value => {\n      returnValue.push(_dropUndefinedKeys(value, memoizationMap));\n    });\n\n    return returnValue ;\n  }\n\n  if (isPojo(inputValue)) {\n    const returnValue = {};\n    // Store mapping to handle circular references\n    memoizationMap.set(inputValue, returnValue);\n\n    const keys = Object.keys(inputValue);\n\n    keys.forEach(key => {\n      const val = inputValue[key];\n      if (val !== undefined) {\n        returnValue[key] = _dropUndefinedKeys(val, memoizationMap);\n      }\n    });\n\n    return returnValue ;\n  }\n\n  // For other object types, return as is\n  return inputValue;\n}\n\nfunction isPojo(input) {\n  // Plain objects have Object as constructor or no constructor\n  const constructor = (input ).constructor;\n  return constructor === Object || constructor === undefined;\n}\n\n/**\n * Ensure that something is an object.\n *\n * Turns `undefined` and `null` into `String`s and all other primitives into instances of their respective wrapper\n * classes (String, Boolean, Number, etc.). Acts as the identity function on non-primitives.\n *\n * @param wat The subject of the objectification\n * @returns A version of `wat` which can safely be used with `Object` class methods\n */\nfunction objectify(wat) {\n  let objectified;\n  switch (true) {\n    // this will catch both undefined and null\n    case wat == undefined:\n      objectified = new String(wat);\n      break;\n\n    // Though symbols and bigints do have wrapper classes (`Symbol` and `BigInt`, respectively), for whatever reason\n    // those classes don't have constructors which can be used with the `new` keyword. We therefore need to cast each as\n    // an object in order to wrap it.\n    case typeof wat === 'symbol' || typeof wat === 'bigint':\n      objectified = Object(wat);\n      break;\n\n    // this will catch the remaining primitives: `String`, `Number`, and `Boolean`\n    case isPrimitive(wat):\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      objectified = new (wat ).constructor(wat);\n      break;\n\n    // by process of elimination, at this point we know that `wat` must already be an object\n    default:\n      objectified = wat;\n      break;\n  }\n  return objectified;\n}\n\nexport { addNonEnumerableProperty, convertToPlainObject, dropUndefinedKeys, extractExceptionKeysForMessage, fill, getOriginalFunction, markFunctionWrapped, objectify };\n//# sourceMappingURL=object.js.map\n","import { addNonEnumerableProperty } from './object.js';\nimport { snipLine } from './string.js';\nimport { GLOBAL_OBJ } from './worldwide.js';\n\nfunction getCrypto() {\n  const gbl = GLOBAL_OBJ ;\n  return gbl.crypto || gbl.msCrypto;\n}\n\n/**\n * UUID4 generator\n * @param crypto Object that provides the crypto API.\n * @returns string Generated UUID4.\n */\nfunction uuid4(crypto = getCrypto()) {\n  let getRandomByte = () => Math.random() * 16;\n  try {\n    if (crypto?.randomUUID) {\n      return crypto.randomUUID().replace(/-/g, '');\n    }\n    if (crypto?.getRandomValues) {\n      getRandomByte = () => {\n        // crypto.getRandomValues might return undefined instead of the typed array\n        // in old Chromium versions (e.g. 23.0.1235.0 (151422))\n        // However, `typedArray` is still filled in-place.\n        // @see https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues#typedarray\n        const typedArray = new Uint8Array(1);\n        crypto.getRandomValues(typedArray);\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return typedArray[0];\n      };\n    }\n  } catch (_) {\n    // some runtimes can crash invoking crypto\n    // https://github.com/getsentry/sentry-javascript/issues/8935\n  }\n\n  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523\n  // Concatenating the following numbers as strings results in '10000000100040008000100000000000'\n  return (([1e7] ) + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, c =>\n    // eslint-disable-next-line no-bitwise\n    ((c ) ^ ((getRandomByte() & 15) >> ((c ) / 4))).toString(16),\n  );\n}\n\nfunction getFirstException(event) {\n  return event.exception?.values?.[0];\n}\n\n/**\n * Extracts either message or type+value from an event that can be used for user-facing logs\n * @returns event's description\n */\nfunction getEventDescription(event) {\n  const { message, event_id: eventId } = event;\n  if (message) {\n    return message;\n  }\n\n  const firstException = getFirstException(event);\n  if (firstException) {\n    if (firstException.type && firstException.value) {\n      return `${firstException.type}: ${firstException.value}`;\n    }\n    return firstException.type || firstException.value || eventId || '<unknown>';\n  }\n  return eventId || '<unknown>';\n}\n\n/**\n * Adds exception values, type and value to an synthetic Exception.\n * @param event The event to modify.\n * @param value Value of the exception.\n * @param type Type of the exception.\n * @hidden\n */\nfunction addExceptionTypeValue(event, value, type) {\n  const exception = (event.exception = event.exception || {});\n  const values = (exception.values = exception.values || []);\n  const firstException = (values[0] = values[0] || {});\n  if (!firstException.value) {\n    firstException.value = value || '';\n  }\n  if (!firstException.type) {\n    firstException.type = type || 'Error';\n  }\n}\n\n/**\n * Adds exception mechanism data to a given event. Uses defaults if the second parameter is not passed.\n *\n * @param event The event to modify.\n * @param newMechanism Mechanism data to add to the event.\n * @hidden\n */\nfunction addExceptionMechanism(event, newMechanism) {\n  const firstException = getFirstException(event);\n  if (!firstException) {\n    return;\n  }\n\n  const defaultMechanism = { type: 'generic', handled: true };\n  const currentMechanism = firstException.mechanism;\n  firstException.mechanism = { ...defaultMechanism, ...currentMechanism, ...newMechanism };\n\n  if (newMechanism && 'data' in newMechanism) {\n    const mergedData = { ...currentMechanism?.data, ...newMechanism.data };\n    firstException.mechanism.data = mergedData;\n  }\n}\n\n// https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\nconst SEMVER_REGEXP =\n  /^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$/;\n\n/**\n * Represents Semantic Versioning object\n */\n\nfunction _parseInt(input) {\n  return parseInt(input || '', 10);\n}\n\n/**\n * Parses input into a SemVer interface\n * @param input string representation of a semver version\n */\nfunction parseSemver(input) {\n  const match = input.match(SEMVER_REGEXP) || [];\n  const major = _parseInt(match[1]);\n  const minor = _parseInt(match[2]);\n  const patch = _parseInt(match[3]);\n  return {\n    buildmetadata: match[5],\n    major: isNaN(major) ? undefined : major,\n    minor: isNaN(minor) ? undefined : minor,\n    patch: isNaN(patch) ? undefined : patch,\n    prerelease: match[4],\n  };\n}\n\n/**\n * This function adds context (pre/post/line) lines to the provided frame\n *\n * @param lines string[] containing all lines\n * @param frame StackFrame that will be mutated\n * @param linesOfContext number of context lines we want to add pre/post\n */\nfunction addContextToFrame(lines, frame, linesOfContext = 5) {\n  // When there is no line number in the frame, attaching context is nonsensical and will even break grouping\n  if (frame.lineno === undefined) {\n    return;\n  }\n\n  const maxLines = lines.length;\n  const sourceLine = Math.max(Math.min(maxLines - 1, frame.lineno - 1), 0);\n\n  frame.pre_context = lines\n    .slice(Math.max(0, sourceLine - linesOfContext), sourceLine)\n    .map((line) => snipLine(line, 0));\n\n  // We guard here to ensure this is not larger than the existing number of lines\n  const lineIndex = Math.min(maxLines - 1, sourceLine);\n\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  frame.context_line = snipLine(lines[lineIndex], frame.colno || 0);\n\n  frame.post_context = lines\n    .slice(Math.min(sourceLine + 1, maxLines), sourceLine + 1 + linesOfContext)\n    .map((line) => snipLine(line, 0));\n}\n\n/**\n * Checks whether or not we've already captured the given exception (note: not an identical exception - the very object\n * in question), and marks it captured if not.\n *\n * This is useful because it's possible for an error to get captured by more than one mechanism. After we intercept and\n * record an error, we rethrow it (assuming we've intercepted it before it's reached the top-level global handlers), so\n * that we don't interfere with whatever effects the error might have had were the SDK not there. At that point, because\n * the error has been rethrown, it's possible for it to bubble up to some other code we've instrumented. If it's not\n * caught after that, it will bubble all the way up to the global handlers (which of course we also instrument). This\n * function helps us ensure that even if we encounter the same error more than once, we only record it the first time we\n * see it.\n *\n * Note: It will ignore primitives (always return `false` and not mark them as seen), as properties can't be set on\n * them. {@link: Object.objectify} can be used on exceptions to convert any that are primitives into their equivalent\n * object wrapper forms so that this check will always work. However, because we need to flag the exact object which\n * will get rethrown, and because that rethrowing happens outside of the event processing pipeline, the objectification\n * must be done before the exception captured.\n *\n * @param A thrown exception to check or flag as having been seen\n * @returns `true` if the exception has already been captured, `false` if not (with the side effect of marking it seen)\n */\nfunction checkOrSetAlreadyCaught(exception) {\n  if (isAlreadyCaptured(exception)) {\n    return true;\n  }\n\n  try {\n    // set it this way rather than by assignment so that it's not ennumerable and therefore isn't recorded by the\n    // `ExtraErrorData` integration\n    addNonEnumerableProperty(exception , '__sentry_captured__', true);\n  } catch (err) {\n    // `exception` is a primitive, so we can't mark it seen\n  }\n\n  return false;\n}\n\nfunction isAlreadyCaptured(exception) {\n  try {\n    return (exception ).__sentry_captured__;\n  } catch {} // eslint-disable-line no-empty\n}\n\nexport { addContextToFrame, addExceptionMechanism, addExceptionTypeValue, checkOrSetAlreadyCaught, getEventDescription, parseSemver, uuid4 };\n//# sourceMappingURL=misc.js.map\n","import { GLOBAL_OBJ } from './worldwide.js';\n\nconst ONE_SECOND_IN_MS = 1000;\n\n/**\n * A partial definition of the [Performance Web API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Performance}\n * for accessing a high-resolution monotonic clock.\n */\n\n/**\n * Returns a timestamp in seconds since the UNIX epoch using the Date API.\n */\nfunction dateTimestampInSeconds() {\n  return Date.now() / ONE_SECOND_IN_MS;\n}\n\n/**\n * Returns a wrapper around the native Performance API browser implementation, or undefined for browsers that do not\n * support the API.\n *\n * Wrapping the native API works around differences in behavior from different browsers.\n */\nfunction createUnixTimestampInSecondsFunc() {\n  const { performance } = GLOBAL_OBJ ;\n  if (!performance?.now) {\n    return dateTimestampInSeconds;\n  }\n\n  // Some browser and environments don't have a timeOrigin, so we fallback to\n  // using Date.now() to compute the starting time.\n  const approxStartingTimeOrigin = Date.now() - performance.now();\n  const timeOrigin = performance.timeOrigin == undefined ? approxStartingTimeOrigin : performance.timeOrigin;\n\n  // performance.now() is a monotonic clock, which means it starts at 0 when the process begins. To get the current\n  // wall clock time (actual UNIX timestamp), we need to add the starting time origin and the current time elapsed.\n  //\n  // TODO: This does not account for the case where the monotonic clock that powers performance.now() drifts from the\n  // wall clock time, which causes the returned timestamp to be inaccurate. We should investigate how to detect and\n  // correct for this.\n  // See: https://github.com/getsentry/sentry-javascript/issues/2590\n  // See: https://github.com/mdn/content/issues/4713\n  // See: https://dev.to/noamr/when-a-millisecond-is-not-a-millisecond-3h6\n  return () => {\n    return (timeOrigin + performance.now()) / ONE_SECOND_IN_MS;\n  };\n}\n\n/**\n * Returns a timestamp in seconds since the UNIX epoch using either the Performance or Date APIs, depending on the\n * availability of the Performance API.\n *\n * BUG: Note that because of how browsers implement the Performance API, the clock might stop when the computer is\n * asleep. This creates a skew between `dateTimestampInSeconds` and `timestampInSeconds`. The\n * skew can grow to arbitrary amounts like days, weeks or months.\n * See https://github.com/getsentry/sentry-javascript/issues/2590.\n */\nconst timestampInSeconds = createUnixTimestampInSecondsFunc();\n\n/**\n * Cached result of getBrowserTimeOrigin.\n */\nlet cachedTimeOrigin;\n\n/**\n * Gets the time origin and the mode used to determine it.\n */\nfunction getBrowserTimeOrigin() {\n  // Unfortunately browsers may report an inaccurate time origin data, through either performance.timeOrigin or\n  // performance.timing.navigationStart, which results in poor results in performance data. We only treat time origin\n  // data as reliable if they are within a reasonable threshold of the current time.\n\n  const { performance } = GLOBAL_OBJ ;\n  if (!performance?.now) {\n    return [undefined, 'none'];\n  }\n\n  const threshold = 3600 * 1000;\n  const performanceNow = performance.now();\n  const dateNow = Date.now();\n\n  // if timeOrigin isn't available set delta to threshold so it isn't used\n  const timeOriginDelta = performance.timeOrigin\n    ? Math.abs(performance.timeOrigin + performanceNow - dateNow)\n    : threshold;\n  const timeOriginIsReliable = timeOriginDelta < threshold;\n\n  // While performance.timing.navigationStart is deprecated in favor of performance.timeOrigin, performance.timeOrigin\n  // is not as widely supported. Namely, performance.timeOrigin is undefined in Safari as of writing.\n  // Also as of writing, performance.timing is not available in Web Workers in mainstream browsers, so it is not always\n  // a valid fallback. In the absence of an initial time provided by the browser, fallback to the current time from the\n  // Date API.\n  // eslint-disable-next-line deprecation/deprecation\n  const navigationStart = performance.timing?.navigationStart;\n  const hasNavigationStart = typeof navigationStart === 'number';\n  // if navigationStart isn't available set delta to threshold so it isn't used\n  const navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;\n  const navigationStartIsReliable = navigationStartDelta < threshold;\n\n  if (timeOriginIsReliable || navigationStartIsReliable) {\n    // Use the more reliable time origin\n    if (timeOriginDelta <= navigationStartDelta) {\n      return [performance.timeOrigin, 'timeOrigin'];\n    } else {\n      return [navigationStart, 'navigationStart'];\n    }\n  }\n\n  // Either both timeOrigin and navigationStart are skewed or neither is available, fallback to Date.\n  return [dateNow, 'dateNow'];\n}\n\n/**\n * The number of milliseconds since the UNIX epoch. This value is only usable in a browser, and only when the\n * performance API is available.\n */\nfunction browserPerformanceTimeOrigin() {\n  if (!cachedTimeOrigin) {\n    cachedTimeOrigin = getBrowserTimeOrigin();\n  }\n\n  return cachedTimeOrigin[0];\n}\n\nexport { browserPerformanceTimeOrigin, dateTimestampInSeconds, timestampInSeconds };\n//# sourceMappingURL=time.js.map\n","import { uuid4 } from './utils/misc.js';\nimport { timestampInSeconds } from './utils/time.js';\n\n/**\n * Creates a new `Session` object by setting certain default parameters. If optional @param context\n * is passed, the passed properties are applied to the session object.\n *\n * @param context (optional) additional properties to be applied to the returned session object\n *\n * @returns a new `Session` object\n */\nfunction makeSession(context) {\n  // Both timestamp and started are in seconds since the UNIX epoch.\n  const startingTime = timestampInSeconds();\n\n  const session = {\n    sid: uuid4(),\n    init: true,\n    timestamp: startingTime,\n    started: startingTime,\n    duration: 0,\n    status: 'ok',\n    errors: 0,\n    ignoreDuration: false,\n    toJSON: () => sessionToJSON(session),\n  };\n\n  if (context) {\n    updateSession(session, context);\n  }\n\n  return session;\n}\n\n/**\n * Updates a session object with the properties passed in the context.\n *\n * Note that this function mutates the passed object and returns void.\n * (Had to do this instead of returning a new and updated session because closing and sending a session\n * makes an update to the session after it was passed to the sending logic.\n * @see Client.captureSession )\n *\n * @param session the `Session` to update\n * @param context the `SessionContext` holding the properties that should be updated in @param session\n */\n// eslint-disable-next-line complexity\nfunction updateSession(session, context = {}) {\n  if (context.user) {\n    if (!session.ipAddress && context.user.ip_address) {\n      session.ipAddress = context.user.ip_address;\n    }\n\n    if (!session.did && !context.did) {\n      session.did = context.user.id || context.user.email || context.user.username;\n    }\n  }\n\n  session.timestamp = context.timestamp || timestampInSeconds();\n\n  if (context.abnormal_mechanism) {\n    session.abnormal_mechanism = context.abnormal_mechanism;\n  }\n\n  if (context.ignoreDuration) {\n    session.ignoreDuration = context.ignoreDuration;\n  }\n  if (context.sid) {\n    // Good enough uuid validation.  Kamil\n    session.sid = context.sid.length === 32 ? context.sid : uuid4();\n  }\n  if (context.init !== undefined) {\n    session.init = context.init;\n  }\n  if (!session.did && context.did) {\n    session.did = `${context.did}`;\n  }\n  if (typeof context.started === 'number') {\n    session.started = context.started;\n  }\n  if (session.ignoreDuration) {\n    session.duration = undefined;\n  } else if (typeof context.duration === 'number') {\n    session.duration = context.duration;\n  } else {\n    const duration = session.timestamp - session.started;\n    session.duration = duration >= 0 ? duration : 0;\n  }\n  if (context.release) {\n    session.release = context.release;\n  }\n  if (context.environment) {\n    session.environment = context.environment;\n  }\n  if (!session.ipAddress && context.ipAddress) {\n    session.ipAddress = context.ipAddress;\n  }\n  if (!session.userAgent && context.userAgent) {\n    session.userAgent = context.userAgent;\n  }\n  if (typeof context.errors === 'number') {\n    session.errors = context.errors;\n  }\n  if (context.status) {\n    session.status = context.status;\n  }\n}\n\n/**\n * Closes a session by setting its status and updating the session object with it.\n * Internally calls `updateSession` to update the passed session object.\n *\n * Note that this function mutates the passed session (@see updateSession for explanation).\n *\n * @param session the `Session` object to be closed\n * @param status the `SessionStatus` with which the session was closed. If you don't pass a status,\n *               this function will keep the previously set status, unless it was `'ok'` in which case\n *               it is changed to `'exited'`.\n */\nfunction closeSession(session, status) {\n  let context = {};\n  if (status) {\n    context = { status };\n  } else if (session.status === 'ok') {\n    context = { status: 'exited' };\n  }\n\n  updateSession(session, context);\n}\n\n/**\n * Serializes a passed session object to a JSON object with a slightly different structure.\n * This is necessary because the Sentry backend requires a slightly different schema of a session\n * than the one the JS SDKs use internally.\n *\n * @param session the session to be converted\n *\n * @returns a JSON object of the passed session\n */\nfunction sessionToJSON(session) {\n  return {\n    sid: `${session.sid}`,\n    init: session.init,\n    // Make sure that sec is converted to ms for date constructor\n    started: new Date(session.started * 1000).toISOString(),\n    timestamp: new Date(session.timestamp * 1000).toISOString(),\n    status: session.status,\n    errors: session.errors,\n    did: typeof session.did === 'number' || typeof session.did === 'string' ? `${session.did}` : undefined,\n    duration: session.duration,\n    abnormal_mechanism: session.abnormal_mechanism,\n    attrs: {\n      release: session.release,\n      environment: session.environment,\n      ip_address: session.ipAddress,\n      user_agent: session.userAgent,\n    },\n  };\n}\n\nexport { closeSession, makeSession, updateSession };\n//# sourceMappingURL=session.js.map\n","/**\n * Shallow merge two objects.\n * Does not mutate the passed in objects.\n * Undefined/empty values in the merge object will overwrite existing values.\n *\n * By default, this merges 2 levels deep.\n */\nfunction merge(initialObj, mergeObj, levels = 2) {\n  // If the merge value is not an object, or we have no merge levels left,\n  // we just set the value to the merge value\n  if (!mergeObj || typeof mergeObj !== 'object' || levels <= 0) {\n    return mergeObj;\n  }\n\n  // If the merge object is an empty object, and the initial object is not undefined, we return the initial object\n  if (initialObj && Object.keys(mergeObj).length === 0) {\n    return initialObj;\n  }\n\n  // Clone object\n  const output = { ...initialObj };\n\n  // Merge values into output, resursively\n  for (const key in mergeObj) {\n    if (Object.prototype.hasOwnProperty.call(mergeObj, key)) {\n      output[key] = merge(output[key], mergeObj[key], levels - 1);\n    }\n  }\n\n  return output;\n}\n\nexport { merge };\n//# sourceMappingURL=merge.js.map\n","import { uuid4 } from './misc.js';\n\n/**\n * Generate a random, valid trace ID.\n */\nfunction generateTraceId() {\n  return uuid4();\n}\n\n/**\n * Generate a random, valid span ID.\n */\nfunction generateSpanId() {\n  return uuid4().substring(16);\n}\n\nexport { generateSpanId, generateTraceId };\n//# sourceMappingURL=propagationContext.js.map\n","import { addNonEnumerableProperty } from './object.js';\n\nconst SCOPE_SPAN_FIELD = '_sentrySpan';\n\n/**\n * Set the active span for a given scope.\n * NOTE: This should NOT be used directly, but is only used internally by the trace methods.\n */\nfunction _setSpanForScope(scope, span) {\n  if (span) {\n    addNonEnumerableProperty(scope , SCOPE_SPAN_FIELD, span);\n  } else {\n    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n    delete (scope )[SCOPE_SPAN_FIELD];\n  }\n}\n\n/**\n * Get the active span for a given scope.\n * NOTE: This should NOT be used directly, but is only used internally by the trace methods.\n */\nfunction _getSpanForScope(scope) {\n  return scope[SCOPE_SPAN_FIELD];\n}\n\nexport { _getSpanForScope, _setSpanForScope };\n//# sourceMappingURL=spanOnScope.js.map\n","import { updateSession } from './session.js';\nimport { isPlainObject } from './utils/is.js';\nimport { logger } from './utils/logger.js';\nimport { merge } from './utils/merge.js';\nimport { uuid4 } from './utils/misc.js';\nimport { generateTraceId } from './utils/propagationContext.js';\nimport { _setSpanForScope, _getSpanForScope } from './utils/spanOnScope.js';\nimport { truncate } from './utils/string.js';\nimport { dateTimestampInSeconds } from './utils/time.js';\n\n/**\n * Default value for maximum number of breadcrumbs added to an event.\n */\nconst DEFAULT_MAX_BREADCRUMBS = 100;\n\n/**\n * A context to be used for capturing an event.\n * This can either be a Scope, or a partial ScopeContext,\n * or a callback that receives the current scope and returns a new scope to use.\n */\n\n/**\n * Holds additional event information.\n */\nclass Scope {\n  /** Flag if notifying is happening. */\n\n  /** Callback for client to receive scope changes. */\n\n  /** Callback list that will be called during event processing. */\n\n  /** Array of breadcrumbs. */\n\n  /** User */\n\n  /** Tags */\n\n  /** Extra */\n\n  /** Contexts */\n\n  /** Attachments */\n\n  /** Propagation Context for distributed tracing */\n\n  /**\n   * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get\n   * sent to Sentry\n   */\n\n  /** Fingerprint */\n\n  /** Severity */\n\n  /**\n   * Transaction Name\n   *\n   * IMPORTANT: The transaction name on the scope has nothing to do with root spans/transaction objects.\n   * It's purpose is to assign a transaction to the scope that's added to non-transaction events.\n   */\n\n  /** Session */\n\n  /** The client on this scope */\n\n  /** Contains the last event id of a captured event.  */\n\n  // NOTE: Any field which gets added here should get added not only to the constructor but also to the `clone` method.\n\n   constructor() {\n    this._notifyingListeners = false;\n    this._scopeListeners = [];\n    this._eventProcessors = [];\n    this._breadcrumbs = [];\n    this._attachments = [];\n    this._user = {};\n    this._tags = {};\n    this._extra = {};\n    this._contexts = {};\n    this._sdkProcessingMetadata = {};\n    this._propagationContext = {\n      traceId: generateTraceId(),\n      sampleRand: Math.random(),\n    };\n  }\n\n  /**\n   * Clone all data from this scope into a new scope.\n   */\n   clone() {\n    const newScope = new Scope();\n    newScope._breadcrumbs = [...this._breadcrumbs];\n    newScope._tags = { ...this._tags };\n    newScope._extra = { ...this._extra };\n    newScope._contexts = { ...this._contexts };\n    if (this._contexts.flags) {\n      // We need to copy the `values` array so insertions on a cloned scope\n      // won't affect the original array.\n      newScope._contexts.flags = {\n        values: [...this._contexts.flags.values],\n      };\n    }\n\n    newScope._user = this._user;\n    newScope._level = this._level;\n    newScope._session = this._session;\n    newScope._transactionName = this._transactionName;\n    newScope._fingerprint = this._fingerprint;\n    newScope._eventProcessors = [...this._eventProcessors];\n    newScope._attachments = [...this._attachments];\n    newScope._sdkProcessingMetadata = { ...this._sdkProcessingMetadata };\n    newScope._propagationContext = { ...this._propagationContext };\n    newScope._client = this._client;\n    newScope._lastEventId = this._lastEventId;\n\n    _setSpanForScope(newScope, _getSpanForScope(this));\n\n    return newScope;\n  }\n\n  /**\n   * Update the client assigned to this scope.\n   * Note that not every scope will have a client assigned - isolation scopes & the global scope will generally not have a client,\n   * as well as manually created scopes.\n   */\n   setClient(client) {\n    this._client = client;\n  }\n\n  /**\n   * Set the ID of the last captured error event.\n   * This is generally only captured on the isolation scope.\n   */\n   setLastEventId(lastEventId) {\n    this._lastEventId = lastEventId;\n  }\n\n  /**\n   * Get the client assigned to this scope.\n   */\n   getClient() {\n    return this._client ;\n  }\n\n  /**\n   * Get the ID of the last captured error event.\n   * This is generally only available on the isolation scope.\n   */\n   lastEventId() {\n    return this._lastEventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   addScopeListener(callback) {\n    this._scopeListeners.push(callback);\n  }\n\n  /**\n   * Add an event processor that will be called before an event is sent.\n   */\n   addEventProcessor(callback) {\n    this._eventProcessors.push(callback);\n    return this;\n  }\n\n  /**\n   * Set the user for this scope.\n   * Set to `null` to unset the user.\n   */\n   setUser(user) {\n    // If null is passed we want to unset everything, but still define keys,\n    // so that later down in the pipeline any existing values are cleared.\n    this._user = user || {\n      email: undefined,\n      id: undefined,\n      ip_address: undefined,\n      username: undefined,\n    };\n\n    if (this._session) {\n      updateSession(this._session, { user });\n    }\n\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Get the user from this scope.\n   */\n   getUser() {\n    return this._user;\n  }\n\n  /**\n   * Set an object that will be merged into existing tags on the scope,\n   * and will be sent as tags data with the event.\n   */\n   setTags(tags) {\n    this._tags = {\n      ...this._tags,\n      ...tags,\n    };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Set a single tag that will be sent as tags data with the event.\n   */\n   setTag(key, value) {\n    this._tags = { ...this._tags, [key]: value };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Set an object that will be merged into existing extra on the scope,\n   * and will be sent as extra data with the event.\n   */\n   setExtras(extras) {\n    this._extra = {\n      ...this._extra,\n      ...extras,\n    };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Set a single key:value extra entry that will be sent as extra data with the event.\n   */\n   setExtra(key, extra) {\n    this._extra = { ...this._extra, [key]: extra };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Sets the fingerprint on the scope to send with the events.\n   * @param {string[]} fingerprint Fingerprint to group events in Sentry.\n   */\n   setFingerprint(fingerprint) {\n    this._fingerprint = fingerprint;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Sets the level on the scope for future events.\n   */\n   setLevel(level) {\n    this._level = level;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Sets the transaction name on the scope so that the name of e.g. taken server route or\n   * the page location is attached to future events.\n   *\n   * IMPORTANT: Calling this function does NOT change the name of the currently active\n   * root span. If you want to change the name of the active root span, use\n   * `Sentry.updateSpanName(rootSpan, 'new name')` instead.\n   *\n   * By default, the SDK updates the scope's transaction name automatically on sensible\n   * occasions, such as a page navigation or when handling a new request on the server.\n   */\n   setTransactionName(name) {\n    this._transactionName = name;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Sets context data with the given name.\n   * Data passed as context will be normalized. You can also pass `null` to unset the context.\n   * Note that context data will not be merged - calling `setContext` will overwrite an existing context with the same key.\n   */\n   setContext(key, context) {\n    if (context === null) {\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete this._contexts[key];\n    } else {\n      this._contexts[key] = context;\n    }\n\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Set the session for the scope.\n   */\n   setSession(session) {\n    if (!session) {\n      delete this._session;\n    } else {\n      this._session = session;\n    }\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Get the session from the scope.\n   */\n   getSession() {\n    return this._session;\n  }\n\n  /**\n   * Updates the scope with provided data. Can work in three variations:\n   * - plain object containing updatable attributes\n   * - Scope instance that'll extract the attributes from\n   * - callback function that'll receive the current scope as an argument and allow for modifications\n   */\n   update(captureContext) {\n    if (!captureContext) {\n      return this;\n    }\n\n    const scopeToMerge = typeof captureContext === 'function' ? captureContext(this) : captureContext;\n\n    const scopeInstance =\n      scopeToMerge instanceof Scope\n        ? scopeToMerge.getScopeData()\n        : isPlainObject(scopeToMerge)\n          ? (captureContext )\n          : undefined;\n\n    const { tags, extra, user, contexts, level, fingerprint = [], propagationContext } = scopeInstance || {};\n\n    this._tags = { ...this._tags, ...tags };\n    this._extra = { ...this._extra, ...extra };\n    this._contexts = { ...this._contexts, ...contexts };\n\n    if (user && Object.keys(user).length) {\n      this._user = user;\n    }\n\n    if (level) {\n      this._level = level;\n    }\n\n    if (fingerprint.length) {\n      this._fingerprint = fingerprint;\n    }\n\n    if (propagationContext) {\n      this._propagationContext = propagationContext;\n    }\n\n    return this;\n  }\n\n  /**\n   * Clears the current scope and resets its properties.\n   * Note: The client will not be cleared.\n   */\n   clear() {\n    // client is not cleared here on purpose!\n    this._breadcrumbs = [];\n    this._tags = {};\n    this._extra = {};\n    this._user = {};\n    this._contexts = {};\n    this._level = undefined;\n    this._transactionName = undefined;\n    this._fingerprint = undefined;\n    this._session = undefined;\n    _setSpanForScope(this, undefined);\n    this._attachments = [];\n    this.setPropagationContext({ traceId: generateTraceId(), sampleRand: Math.random() });\n\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Adds a breadcrumb to the scope.\n   * By default, the last 100 breadcrumbs are kept.\n   */\n   addBreadcrumb(breadcrumb, maxBreadcrumbs) {\n    const maxCrumbs = typeof maxBreadcrumbs === 'number' ? maxBreadcrumbs : DEFAULT_MAX_BREADCRUMBS;\n\n    // No data has been changed, so don't notify scope listeners\n    if (maxCrumbs <= 0) {\n      return this;\n    }\n\n    const mergedBreadcrumb = {\n      timestamp: dateTimestampInSeconds(),\n      ...breadcrumb,\n      // Breadcrumb messages can theoretically be infinitely large and they're held in memory so we truncate them not to leak (too much) memory\n      message: breadcrumb.message ? truncate(breadcrumb.message, 2048) : breadcrumb.message,\n    };\n\n    this._breadcrumbs.push(mergedBreadcrumb);\n    if (this._breadcrumbs.length > maxCrumbs) {\n      this._breadcrumbs = this._breadcrumbs.slice(-maxCrumbs);\n      this._client?.recordDroppedEvent('buffer_overflow', 'log_item');\n    }\n\n    this._notifyScopeListeners();\n\n    return this;\n  }\n\n  /**\n   * Get the last breadcrumb of the scope.\n   */\n   getLastBreadcrumb() {\n    return this._breadcrumbs[this._breadcrumbs.length - 1];\n  }\n\n  /**\n   * Clear all breadcrumbs from the scope.\n   */\n   clearBreadcrumbs() {\n    this._breadcrumbs = [];\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Add an attachment to the scope.\n   */\n   addAttachment(attachment) {\n    this._attachments.push(attachment);\n    return this;\n  }\n\n  /**\n   * Clear all attachments from the scope.\n   */\n   clearAttachments() {\n    this._attachments = [];\n    return this;\n  }\n\n  /**\n   * Get the data of this scope, which should be applied to an event during processing.\n   */\n   getScopeData() {\n    return {\n      breadcrumbs: this._breadcrumbs,\n      attachments: this._attachments,\n      contexts: this._contexts,\n      tags: this._tags,\n      extra: this._extra,\n      user: this._user,\n      level: this._level,\n      fingerprint: this._fingerprint || [],\n      eventProcessors: this._eventProcessors,\n      propagationContext: this._propagationContext,\n      sdkProcessingMetadata: this._sdkProcessingMetadata,\n      transactionName: this._transactionName,\n      span: _getSpanForScope(this),\n    };\n  }\n\n  /**\n   * Add data which will be accessible during event processing but won't get sent to Sentry.\n   */\n   setSDKProcessingMetadata(newData) {\n    this._sdkProcessingMetadata = merge(this._sdkProcessingMetadata, newData, 2);\n    return this;\n  }\n\n  /**\n   * Add propagation context to the scope, used for distributed tracing\n   */\n   setPropagationContext(context) {\n    this._propagationContext = context;\n    return this;\n  }\n\n  /**\n   * Get propagation context from the scope, used for distributed tracing\n   */\n   getPropagationContext() {\n    return this._propagationContext;\n  }\n\n  /**\n   * Capture an exception for this scope.\n   *\n   * @returns {string} The id of the captured Sentry event.\n   */\n   captureException(exception, hint) {\n    const eventId = hint?.event_id || uuid4();\n\n    if (!this._client) {\n      logger.warn('No client configured on scope - will not capture exception!');\n      return eventId;\n    }\n\n    const syntheticException = new Error('Sentry syntheticException');\n\n    this._client.captureException(\n      exception,\n      {\n        originalException: exception,\n        syntheticException,\n        ...hint,\n        event_id: eventId,\n      },\n      this,\n    );\n\n    return eventId;\n  }\n\n  /**\n   * Capture a message for this scope.\n   *\n   * @returns {string} The id of the captured message.\n   */\n   captureMessage(message, level, hint) {\n    const eventId = hint?.event_id || uuid4();\n\n    if (!this._client) {\n      logger.warn('No client configured on scope - will not capture message!');\n      return eventId;\n    }\n\n    const syntheticException = new Error(message);\n\n    this._client.captureMessage(\n      message,\n      level,\n      {\n        originalException: message,\n        syntheticException,\n        ...hint,\n        event_id: eventId,\n      },\n      this,\n    );\n\n    return eventId;\n  }\n\n  /**\n   * Capture a Sentry event for this scope.\n   *\n   * @returns {string} The id of the captured event.\n   */\n   captureEvent(event, hint) {\n    const eventId = hint?.event_id || uuid4();\n\n    if (!this._client) {\n      logger.warn('No client configured on scope - will not capture event!');\n      return eventId;\n    }\n\n    this._client.captureEvent(event, { ...hint, event_id: eventId }, this);\n\n    return eventId;\n  }\n\n  /**\n   * This will be called on every set call.\n   */\n   _notifyScopeListeners() {\n    // We need this check for this._notifyingListeners to be able to work on scope during updates\n    // If this check is not here we'll produce endless recursion when something is done with the scope\n    // during the callback.\n    if (!this._notifyingListeners) {\n      this._notifyingListeners = true;\n      this._scopeListeners.forEach(callback => {\n        callback(this);\n      });\n      this._notifyingListeners = false;\n    }\n  }\n}\n\nexport { Scope };\n//# sourceMappingURL=scope.js.map\n","import { getGlobalSingleton } from './carrier.js';\nimport { Scope } from './scope.js';\n\n/** Get the default current scope. */\nfunction getDefaultCurrentScope() {\n  return getGlobalSingleton('defaultCurrentScope', () => new Scope());\n}\n\n/** Get the default isolation scope. */\nfunction getDefaultIsolationScope() {\n  return getGlobalSingleton('defaultIsolationScope', () => new Scope());\n}\n\nexport { getDefaultCurrentScope, getDefaultIsolationScope };\n//# sourceMappingURL=defaultScopes.js.map\n","import { getDefaultCurrentScope, getDefaultIsolationScope } from '../defaultScopes.js';\nimport { Scope } from '../scope.js';\nimport { isThenable } from '../utils/is.js';\nimport { getMainCarrier, getSentryCarrier } from '../carrier.js';\n\n/**\n * This is an object that holds a stack of scopes.\n */\nclass AsyncContextStack {\n\n   constructor(scope, isolationScope) {\n    let assignedScope;\n    if (!scope) {\n      assignedScope = new Scope();\n    } else {\n      assignedScope = scope;\n    }\n\n    let assignedIsolationScope;\n    if (!isolationScope) {\n      assignedIsolationScope = new Scope();\n    } else {\n      assignedIsolationScope = isolationScope;\n    }\n\n    // scope stack for domains or the process\n    this._stack = [{ scope: assignedScope }];\n    this._isolationScope = assignedIsolationScope;\n  }\n\n  /**\n   * Fork a scope for the stack.\n   */\n   withScope(callback) {\n    const scope = this._pushScope();\n\n    let maybePromiseResult;\n    try {\n      maybePromiseResult = callback(scope);\n    } catch (e) {\n      this._popScope();\n      throw e;\n    }\n\n    if (isThenable(maybePromiseResult)) {\n      // @ts-expect-error - isThenable returns the wrong type\n      return maybePromiseResult.then(\n        res => {\n          this._popScope();\n          return res;\n        },\n        e => {\n          this._popScope();\n          throw e;\n        },\n      );\n    }\n\n    this._popScope();\n    return maybePromiseResult;\n  }\n\n  /**\n   * Get the client of the stack.\n   */\n   getClient() {\n    return this.getStackTop().client ;\n  }\n\n  /**\n   * Returns the scope of the top stack.\n   */\n   getScope() {\n    return this.getStackTop().scope;\n  }\n\n  /**\n   * Get the isolation scope for the stack.\n   */\n   getIsolationScope() {\n    return this._isolationScope;\n  }\n\n  /**\n   * Returns the topmost scope layer in the order domain > local > process.\n   */\n   getStackTop() {\n    return this._stack[this._stack.length - 1] ;\n  }\n\n  /**\n   * Push a scope to the stack.\n   */\n   _pushScope() {\n    // We want to clone the content of prev scope\n    const scope = this.getScope().clone();\n    this._stack.push({\n      client: this.getClient(),\n      scope,\n    });\n    return scope;\n  }\n\n  /**\n   * Pop a scope from the stack.\n   */\n   _popScope() {\n    if (this._stack.length <= 1) return false;\n    return !!this._stack.pop();\n  }\n}\n\n/**\n * Get the global async context stack.\n * This will be removed during the v8 cycle and is only here to make migration easier.\n */\nfunction getAsyncContextStack() {\n  const registry = getMainCarrier();\n  const sentry = getSentryCarrier(registry);\n\n  return (sentry.stack = sentry.stack || new AsyncContextStack(getDefaultCurrentScope(), getDefaultIsolationScope()));\n}\n\nfunction withScope(callback) {\n  return getAsyncContextStack().withScope(callback);\n}\n\nfunction withSetScope(scope, callback) {\n  const stack = getAsyncContextStack() ;\n  return stack.withScope(() => {\n    stack.getStackTop().scope = scope;\n    return callback(scope);\n  });\n}\n\nfunction withIsolationScope(callback) {\n  return getAsyncContextStack().withScope(() => {\n    return callback(getAsyncContextStack().getIsolationScope());\n  });\n}\n\n/**\n * Get the stack-based async context strategy.\n */\nfunction getStackAsyncContextStrategy() {\n  return {\n    withIsolationScope,\n    withScope,\n    withSetScope,\n    withSetIsolationScope: (_isolationScope, callback) => {\n      return withIsolationScope(callback);\n    },\n    getCurrentScope: () => getAsyncContextStack().getScope(),\n    getIsolationScope: () => getAsyncContextStack().getIsolationScope(),\n  };\n}\n\nexport { AsyncContextStack, getStackAsyncContextStrategy };\n//# sourceMappingURL=stackStrategy.js.map\n","import { getMainCarrier, getSentryCarrier } from '../carrier.js';\nimport { getStackAsyncContextStrategy } from './stackStrategy.js';\n\n/**\n * @private Private API with no semver guarantees!\n *\n * Sets the global async context strategy\n */\nfunction setAsyncContextStrategy(strategy) {\n  // Get main carrier (global for every environment)\n  const registry = getMainCarrier();\n  const sentry = getSentryCarrier(registry);\n  sentry.acs = strategy;\n}\n\n/**\n * Get the current async context strategy.\n * If none has been setup, the default will be used.\n */\nfunction getAsyncContextStrategy(carrier) {\n  const sentry = getSentryCarrier(carrier);\n\n  if (sentry.acs) {\n    return sentry.acs;\n  }\n\n  // Otherwise, use the default one (stack)\n  return getStackAsyncContextStrategy();\n}\n\nexport { getAsyncContextStrategy, setAsyncContextStrategy };\n//# sourceMappingURL=index.js.map\n","import { getAsyncContextStrategy } from './asyncContext/index.js';\nimport { getMainCarrier, getGlobalSingleton } from './carrier.js';\nimport { Scope } from './scope.js';\nimport { generateSpanId } from './utils/propagationContext.js';\n\n/**\n * Get the currently active scope.\n */\nfunction getCurrentScope() {\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n  return acs.getCurrentScope();\n}\n\n/**\n * Get the currently active isolation scope.\n * The isolation scope is active for the current execution context.\n */\nfunction getIsolationScope() {\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n  return acs.getIsolationScope();\n}\n\n/**\n * Get the global scope.\n * This scope is applied to _all_ events.\n */\nfunction getGlobalScope() {\n  return getGlobalSingleton('globalScope', () => new Scope());\n}\n\n/**\n * Creates a new scope with and executes the given operation within.\n * The scope is automatically removed once the operation\n * finishes or throws.\n */\n\n/**\n * Either creates a new active scope, or sets the given scope as active scope in the given callback.\n */\nfunction withScope(\n  ...rest\n) {\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n\n  // If a scope is defined, we want to make this the active scope instead of the default one\n  if (rest.length === 2) {\n    const [scope, callback] = rest;\n\n    if (!scope) {\n      return acs.withScope(callback);\n    }\n\n    return acs.withSetScope(scope, callback);\n  }\n\n  return acs.withScope(rest[0]);\n}\n\n/**\n * Attempts to fork the current isolation scope and the current scope based on the current async context strategy. If no\n * async context strategy is set, the isolation scope and the current scope will not be forked (this is currently the\n * case, for example, in the browser).\n *\n * Usage of this function in environments without async context strategy is discouraged and may lead to unexpected behaviour.\n *\n * This function is intended for Sentry SDK and SDK integration development. It is not recommended to be used in \"normal\"\n * applications directly because it comes with pitfalls. Use at your own risk!\n */\n\n/**\n * Either creates a new active isolation scope, or sets the given isolation scope as active scope in the given callback.\n */\nfunction withIsolationScope(\n  ...rest\n\n) {\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n\n  // If a scope is defined, we want to make this the active scope instead of the default one\n  if (rest.length === 2) {\n    const [isolationScope, callback] = rest;\n\n    if (!isolationScope) {\n      return acs.withIsolationScope(callback);\n    }\n\n    return acs.withSetIsolationScope(isolationScope, callback);\n  }\n\n  return acs.withIsolationScope(rest[0]);\n}\n\n/**\n * Get the currently active client.\n */\nfunction getClient() {\n  return getCurrentScope().getClient();\n}\n\n/**\n * Get a trace context for the given scope.\n */\nfunction getTraceContextFromScope(scope) {\n  const propagationContext = scope.getPropagationContext();\n\n  const { traceId, parentSpanId, propagationSpanId } = propagationContext;\n\n  const traceContext = {\n    trace_id: traceId,\n    span_id: propagationSpanId || generateSpanId(),\n  };\n\n  if (parentSpanId) {\n    traceContext.parent_span_id = parentSpanId;\n  }\n\n  return traceContext;\n}\n\nexport { getClient, getCurrentScope, getGlobalScope, getIsolationScope, getTraceContextFromScope, withIsolationScope, withScope };\n//# sourceMappingURL=currentScopes.js.map\n","/**\n * Use this attribute to represent the source of a span.\n * Should be one of: custom, url, route, view, component, task, unknown\n *\n */\nconst SEMANTIC_ATTRIBUTE_SENTRY_SOURCE = 'sentry.source';\n\n/**\n * Attributes that holds the sample rate that was locally applied to a span.\n * If this attribute is not defined, it means that the span inherited a sampling decision.\n *\n * NOTE: Is only defined on root spans.\n */\nconst SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE = 'sentry.sample_rate';\n\n/**\n * Attribute holding the sample rate of the previous trace.\n * This is used to sample consistently across subsequent traces in the browser SDK.\n *\n * Note: Only defined on root spans, if opted into consistent sampling\n */\nconst SEMANTIC_ATTRIBUTE_SENTRY_PREVIOUS_TRACE_SAMPLE_RATE = 'sentry.previous_trace_sample_rate';\n\n/**\n * Use this attribute to represent the operation of a span.\n */\nconst SEMANTIC_ATTRIBUTE_SENTRY_OP = 'sentry.op';\n\n/**\n * Use this attribute to represent the origin of a span.\n */\nconst SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN = 'sentry.origin';\n\n/** The reason why an idle span finished. */\nconst SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON = 'sentry.idle_span_finish_reason';\n\n/** The unit of a measurement, which may be stored as a TimedEvent. */\nconst SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT = 'sentry.measurement_unit';\n\n/** The value of a measurement, which may be stored as a TimedEvent. */\nconst SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE = 'sentry.measurement_value';\n\n/**\n * A custom span name set by users guaranteed to be taken over any automatically\n * inferred name. This attribute is removed before the span is sent.\n *\n * @internal only meant for internal SDK usage\n * @hidden\n */\nconst SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME = 'sentry.custom_span_name';\n\n/**\n * The id of the profile that this span occurred in.\n */\nconst SEMANTIC_ATTRIBUTE_PROFILE_ID = 'sentry.profile_id';\n\nconst SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME = 'sentry.exclusive_time';\n\nconst SEMANTIC_ATTRIBUTE_CACHE_HIT = 'cache.hit';\n\nconst SEMANTIC_ATTRIBUTE_CACHE_KEY = 'cache.key';\n\nconst SEMANTIC_ATTRIBUTE_CACHE_ITEM_SIZE = 'cache.item_size';\n\n/** TODO: Remove these once we update to latest semantic conventions */\nconst SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD = 'http.request.method';\nconst SEMANTIC_ATTRIBUTE_URL_FULL = 'url.full';\n\n/**\n * A span link attribute to mark the link as a special span link.\n *\n * Known values:\n * - `previous_trace`: The span links to the frontend root span of the previous trace.\n * - `next_trace`: The span links to the frontend root span of the next trace. (Not set by the SDK)\n *\n * Other values may be set as appropriate.\n * @see https://develop.sentry.dev/sdk/telemetry/traces/span-links/#link-types\n */\nconst SEMANTIC_LINK_ATTRIBUTE_LINK_TYPE = 'sentry.link.type';\n\nexport { SEMANTIC_ATTRIBUTE_CACHE_HIT, SEMANTIC_ATTRIBUTE_CACHE_ITEM_SIZE, SEMANTIC_ATTRIBUTE_CACHE_KEY, SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME, SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD, SEMANTIC_ATTRIBUTE_PROFILE_ID, SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME, SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON, SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT, SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE, SEMANTIC_ATTRIBUTE_SENTRY_OP, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, SEMANTIC_ATTRIBUTE_SENTRY_PREVIOUS_TRACE_SAMPLE_RATE, SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, SEMANTIC_ATTRIBUTE_URL_FULL, SEMANTIC_LINK_ATTRIBUTE_LINK_TYPE };\n//# sourceMappingURL=semanticAttributes.js.map\n","const SPAN_STATUS_UNSET = 0;\nconst SPAN_STATUS_OK = 1;\nconst SPAN_STATUS_ERROR = 2;\n\n/**\n * Converts a HTTP status code into a sentry status with a message.\n *\n * @param httpStatus The HTTP response status code.\n * @returns The span status or unknown_error.\n */\n// https://develop.sentry.dev/sdk/event-payloads/span/\nfunction getSpanStatusFromHttpCode(httpStatus) {\n  if (httpStatus < 400 && httpStatus >= 100) {\n    return { code: SPAN_STATUS_OK };\n  }\n\n  if (httpStatus >= 400 && httpStatus < 500) {\n    switch (httpStatus) {\n      case 401:\n        return { code: SPAN_STATUS_ERROR, message: 'unauthenticated' };\n      case 403:\n        return { code: SPAN_STATUS_ERROR, message: 'permission_denied' };\n      case 404:\n        return { code: SPAN_STATUS_ERROR, message: 'not_found' };\n      case 409:\n        return { code: SPAN_STATUS_ERROR, message: 'already_exists' };\n      case 413:\n        return { code: SPAN_STATUS_ERROR, message: 'failed_precondition' };\n      case 429:\n        return { code: SPAN_STATUS_ERROR, message: 'resource_exhausted' };\n      case 499:\n        return { code: SPAN_STATUS_ERROR, message: 'cancelled' };\n      default:\n        return { code: SPAN_STATUS_ERROR, message: 'invalid_argument' };\n    }\n  }\n\n  if (httpStatus >= 500 && httpStatus < 600) {\n    switch (httpStatus) {\n      case 501:\n        return { code: SPAN_STATUS_ERROR, message: 'unimplemented' };\n      case 503:\n        return { code: SPAN_STATUS_ERROR, message: 'unavailable' };\n      case 504:\n        return { code: SPAN_STATUS_ERROR, message: 'deadline_exceeded' };\n      default:\n        return { code: SPAN_STATUS_ERROR, message: 'internal_error' };\n    }\n  }\n\n  return { code: SPAN_STATUS_ERROR, message: 'unknown_error' };\n}\n\n/**\n * Sets the Http status attributes on the current span based on the http code.\n * Additionally, the span's status is updated, depending on the http code.\n */\nfunction setHttpStatus(span, httpStatus) {\n  span.setAttribute('http.response.status_code', httpStatus);\n\n  const spanStatus = getSpanStatusFromHttpCode(httpStatus);\n  if (spanStatus.message !== 'unknown_error') {\n    span.setStatus(spanStatus);\n  }\n}\n\nexport { SPAN_STATUS_ERROR, SPAN_STATUS_OK, SPAN_STATUS_UNSET, getSpanStatusFromHttpCode, setHttpStatus };\n//# sourceMappingURL=spanstatus.js.map\n","import { addNonEnumerableProperty } from '../utils/object.js';\n\nconst SCOPE_ON_START_SPAN_FIELD = '_sentryScope';\nconst ISOLATION_SCOPE_ON_START_SPAN_FIELD = '_sentryIsolationScope';\n\n/** Store the scope & isolation scope for a span, which can the be used when it is finished. */\nfunction setCapturedScopesOnSpan(span, scope, isolationScope) {\n  if (span) {\n    addNonEnumerableProperty(span, ISOLATION_SCOPE_ON_START_SPAN_FIELD, isolationScope);\n    addNonEnumerableProperty(span, SCOPE_ON_START_SPAN_FIELD, scope);\n  }\n}\n\n/**\n * Grabs the scope and isolation scope off a span that were active when the span was started.\n */\nfunction getCapturedScopesOnSpan(span) {\n  return {\n    scope: (span )[SCOPE_ON_START_SPAN_FIELD],\n    isolationScope: (span )[ISOLATION_SCOPE_ON_START_SPAN_FIELD],\n  };\n}\n\nexport { getCapturedScopesOnSpan, setCapturedScopesOnSpan };\n//# sourceMappingURL=utils.js.map\n","import { DEBUG_BUILD } from '../debug-build.js';\nimport { isString } from './is.js';\nimport { logger } from './logger.js';\n\nconst SENTRY_BAGGAGE_KEY_PREFIX = 'sentry-';\n\nconst SENTRY_BAGGAGE_KEY_PREFIX_REGEX = /^sentry-/;\n\n/**\n * Max length of a serialized baggage string\n *\n * https://www.w3.org/TR/baggage/#limits\n */\nconst MAX_BAGGAGE_STRING_LENGTH = 8192;\n\n/**\n * Takes a baggage header and turns it into Dynamic Sampling Context, by extracting all the \"sentry-\" prefixed values\n * from it.\n *\n * @param baggageHeader A very bread definition of a baggage header as it might appear in various frameworks.\n * @returns The Dynamic Sampling Context that was found on `baggageHeader`, if there was any, `undefined` otherwise.\n */\nfunction baggageHeaderToDynamicSamplingContext(\n  // Very liberal definition of what any incoming header might look like\n  baggageHeader,\n) {\n  const baggageObject = parseBaggageHeader(baggageHeader);\n\n  if (!baggageObject) {\n    return undefined;\n  }\n\n  // Read all \"sentry-\" prefixed values out of the baggage object and put it onto a dynamic sampling context object.\n  const dynamicSamplingContext = Object.entries(baggageObject).reduce((acc, [key, value]) => {\n    if (key.match(SENTRY_BAGGAGE_KEY_PREFIX_REGEX)) {\n      const nonPrefixedKey = key.slice(SENTRY_BAGGAGE_KEY_PREFIX.length);\n      acc[nonPrefixedKey] = value;\n    }\n    return acc;\n  }, {});\n\n  // Only return a dynamic sampling context object if there are keys in it.\n  // A keyless object means there were no sentry values on the header, which means that there is no DSC.\n  if (Object.keys(dynamicSamplingContext).length > 0) {\n    return dynamicSamplingContext ;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Turns a Dynamic Sampling Object into a baggage header by prefixing all the keys on the object with \"sentry-\".\n *\n * @param dynamicSamplingContext The Dynamic Sampling Context to turn into a header. For convenience and compatibility\n * with the `getDynamicSamplingContext` method on the Transaction class ,this argument can also be `undefined`. If it is\n * `undefined` the function will return `undefined`.\n * @returns a baggage header, created from `dynamicSamplingContext`, or `undefined` either if `dynamicSamplingContext`\n * was `undefined`, or if `dynamicSamplingContext` didn't contain any values.\n */\nfunction dynamicSamplingContextToSentryBaggageHeader(\n  // this also takes undefined for convenience and bundle size in other places\n  dynamicSamplingContext,\n) {\n  if (!dynamicSamplingContext) {\n    return undefined;\n  }\n\n  // Prefix all DSC keys with \"sentry-\" and put them into a new object\n  const sentryPrefixedDSC = Object.entries(dynamicSamplingContext).reduce(\n    (acc, [dscKey, dscValue]) => {\n      if (dscValue) {\n        acc[`${SENTRY_BAGGAGE_KEY_PREFIX}${dscKey}`] = dscValue;\n      }\n      return acc;\n    },\n    {},\n  );\n\n  return objectToBaggageHeader(sentryPrefixedDSC);\n}\n\n/**\n * Take a baggage header and parse it into an object.\n */\nfunction parseBaggageHeader(\n  baggageHeader,\n) {\n  if (!baggageHeader || (!isString(baggageHeader) && !Array.isArray(baggageHeader))) {\n    return undefined;\n  }\n\n  if (Array.isArray(baggageHeader)) {\n    // Combine all baggage headers into one object containing the baggage values so we can later read the Sentry-DSC-values from it\n    return baggageHeader.reduce((acc, curr) => {\n      const currBaggageObject = baggageHeaderToObject(curr);\n      Object.entries(currBaggageObject).forEach(([key, value]) => {\n        acc[key] = value;\n      });\n      return acc;\n    }, {});\n  }\n\n  return baggageHeaderToObject(baggageHeader);\n}\n\n/**\n * Will parse a baggage header, which is a simple key-value map, into a flat object.\n *\n * @param baggageHeader The baggage header to parse.\n * @returns a flat object containing all the key-value pairs from `baggageHeader`.\n */\nfunction baggageHeaderToObject(baggageHeader) {\n  return baggageHeader\n    .split(',')\n    .map(baggageEntry =>\n      baggageEntry.split('=').map(keyOrValue => {\n        try {\n          return decodeURIComponent(keyOrValue.trim());\n        } catch {\n          // We ignore errors here, e.g. if the value cannot be URL decoded.\n          // This will then be skipped in the next step\n          return;\n        }\n      }),\n    )\n    .reduce((acc, [key, value]) => {\n      if (key && value) {\n        acc[key] = value;\n      }\n      return acc;\n    }, {});\n}\n\n/**\n * Turns a flat object (key-value pairs) into a baggage header, which is also just key-value pairs.\n *\n * @param object The object to turn into a baggage header.\n * @returns a baggage header string, or `undefined` if the object didn't have any values, since an empty baggage header\n * is not spec compliant.\n */\nfunction objectToBaggageHeader(object) {\n  if (Object.keys(object).length === 0) {\n    // An empty baggage header is not spec compliant: We return undefined.\n    return undefined;\n  }\n\n  return Object.entries(object).reduce((baggageHeader, [objectKey, objectValue], currentIndex) => {\n    const baggageEntry = `${encodeURIComponent(objectKey)}=${encodeURIComponent(objectValue)}`;\n    const newBaggageHeader = currentIndex === 0 ? baggageEntry : `${baggageHeader},${baggageEntry}`;\n    if (newBaggageHeader.length > MAX_BAGGAGE_STRING_LENGTH) {\n      DEBUG_BUILD &&\n        logger.warn(\n          `Not adding key: ${objectKey} with val: ${objectValue} to baggage header due to exceeding baggage size limits.`,\n        );\n      return baggageHeader;\n    } else {\n      return newBaggageHeader;\n    }\n  }, '');\n}\n\nexport { MAX_BAGGAGE_STRING_LENGTH, SENTRY_BAGGAGE_KEY_PREFIX, SENTRY_BAGGAGE_KEY_PREFIX_REGEX, baggageHeaderToDynamicSamplingContext, dynamicSamplingContextToSentryBaggageHeader, objectToBaggageHeader, parseBaggageHeader };\n//# sourceMappingURL=baggage.js.map\n","import { getAsyncContextStrategy } from '../asyncContext/index.js';\nimport { getMainCarrier } from '../carrier.js';\nimport { getCurrentScope } from '../currentScopes.js';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, SEMANTIC_ATTRIBUTE_SENTRY_OP, SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE } from '../semanticAttributes.js';\nimport { SPAN_STATUS_UNSET, SPAN_STATUS_OK } from '../tracing/spanstatus.js';\nimport { getCapturedScopesOnSpan } from '../tracing/utils.js';\nimport { consoleSandbox } from './logger.js';\nimport { addNonEnumerableProperty } from './object.js';\nimport { generateSpanId } from './propagationContext.js';\nimport { timestampInSeconds } from './time.js';\nimport { generateSentryTraceHeader } from './tracing.js';\nimport { _getSpanForScope } from './spanOnScope.js';\n\n// These are aligned with OpenTelemetry trace flags\nconst TRACE_FLAG_NONE = 0x0;\nconst TRACE_FLAG_SAMPLED = 0x1;\n\nlet hasShownSpanDropWarning = false;\n\n/**\n * Convert a span to a trace context, which can be sent as the `trace` context in an event.\n * By default, this will only include trace_id, span_id & parent_span_id.\n * If `includeAllData` is true, it will also include data, op, status & origin.\n */\nfunction spanToTransactionTraceContext(span) {\n  const { spanId: span_id, traceId: trace_id } = span.spanContext();\n  const { data, op, parent_span_id, status, origin, links } = spanToJSON(span);\n\n  return {\n    parent_span_id,\n    span_id,\n    trace_id,\n    data,\n    op,\n    status,\n    origin,\n    links,\n  };\n}\n\n/**\n * Convert a span to a trace context, which can be sent as the `trace` context in a non-transaction event.\n */\nfunction spanToTraceContext(span) {\n  const { spanId, traceId: trace_id, isRemote } = span.spanContext();\n\n  // If the span is remote, we use a random/virtual span as span_id to the trace context,\n  // and the remote span as parent_span_id\n  const parent_span_id = isRemote ? spanId : spanToJSON(span).parent_span_id;\n  const scope = getCapturedScopesOnSpan(span).scope;\n\n  const span_id = isRemote ? scope?.getPropagationContext().propagationSpanId || generateSpanId() : spanId;\n\n  return {\n    parent_span_id,\n    span_id,\n    trace_id,\n  };\n}\n\n/**\n * Convert a Span to a Sentry trace header.\n */\nfunction spanToTraceHeader(span) {\n  const { traceId, spanId } = span.spanContext();\n  const sampled = spanIsSampled(span);\n  return generateSentryTraceHeader(traceId, spanId, sampled);\n}\n\n/**\n *  Converts the span links array to a flattened version to be sent within an envelope.\n *\n *  If the links array is empty, it returns `undefined` so the empty value can be dropped before it's sent.\n */\nfunction convertSpanLinksForEnvelope(links) {\n  if (links && links.length > 0) {\n    return links.map(({ context: { spanId, traceId, traceFlags, ...restContext }, attributes }) => ({\n      span_id: spanId,\n      trace_id: traceId,\n      sampled: traceFlags === TRACE_FLAG_SAMPLED,\n      attributes,\n      ...restContext,\n    }));\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Convert a span time input into a timestamp in seconds.\n */\nfunction spanTimeInputToSeconds(input) {\n  if (typeof input === 'number') {\n    return ensureTimestampInSeconds(input);\n  }\n\n  if (Array.isArray(input)) {\n    // See {@link HrTime} for the array-based time format\n    return input[0] + input[1] / 1e9;\n  }\n\n  if (input instanceof Date) {\n    return ensureTimestampInSeconds(input.getTime());\n  }\n\n  return timestampInSeconds();\n}\n\n/**\n * Converts a timestamp to second, if it was in milliseconds, or keeps it as second.\n */\nfunction ensureTimestampInSeconds(timestamp) {\n  const isMs = timestamp > 9999999999;\n  return isMs ? timestamp / 1000 : timestamp;\n}\n\n/**\n * Convert a span to a JSON representation.\n */\n// Note: Because of this, we currently have a circular type dependency (which we opted out of in package.json).\n// This is not avoidable as we need `spanToJSON` in `spanUtils.ts`, which in turn is needed by `span.ts` for backwards compatibility.\n// And `spanToJSON` needs the Span class from `span.ts` to check here.\nfunction spanToJSON(span) {\n  if (spanIsSentrySpan(span)) {\n    return span.getSpanJSON();\n  }\n\n  const { spanId: span_id, traceId: trace_id } = span.spanContext();\n\n  // Handle a span from @opentelemetry/sdk-base-trace's `Span` class\n  if (spanIsOpenTelemetrySdkTraceBaseSpan(span)) {\n    const { attributes, startTime, name, endTime, status, links } = span;\n\n    // In preparation for the next major of OpenTelemetry, we want to support\n    // looking up the parent span id according to the new API\n    // In OTel v1, the parent span id is accessed as `parentSpanId`\n    // In OTel v2, the parent span id is accessed as `spanId` on the `parentSpanContext`\n    const parentSpanId =\n      'parentSpanId' in span\n        ? span.parentSpanId\n        : 'parentSpanContext' in span\n          ? (span.parentSpanContext )?.spanId\n          : undefined;\n\n    return {\n      span_id,\n      trace_id,\n      data: attributes,\n      description: name,\n      parent_span_id: parentSpanId,\n      start_timestamp: spanTimeInputToSeconds(startTime),\n      // This is [0,0] by default in OTEL, in which case we want to interpret this as no end time\n      timestamp: spanTimeInputToSeconds(endTime) || undefined,\n      status: getStatusMessage(status),\n      op: attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP],\n      origin: attributes[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN] ,\n      links: convertSpanLinksForEnvelope(links),\n    };\n  }\n\n  // Finally, at least we have `spanContext()`....\n  // This should not actually happen in reality, but we need to handle it for type safety.\n  return {\n    span_id,\n    trace_id,\n    start_timestamp: 0,\n    data: {},\n  };\n}\n\nfunction spanIsOpenTelemetrySdkTraceBaseSpan(span) {\n  const castSpan = span ;\n  return !!castSpan.attributes && !!castSpan.startTime && !!castSpan.name && !!castSpan.endTime && !!castSpan.status;\n}\n\n/** Exported only for tests. */\n\n/**\n * Sadly, due to circular dependency checks we cannot actually import the Span class here and check for instanceof.\n * :( So instead we approximate this by checking if it has the `getSpanJSON` method.\n */\nfunction spanIsSentrySpan(span) {\n  return typeof (span ).getSpanJSON === 'function';\n}\n\n/**\n * Returns true if a span is sampled.\n * In most cases, you should just use `span.isRecording()` instead.\n * However, this has a slightly different semantic, as it also returns false if the span is finished.\n * So in the case where this distinction is important, use this method.\n */\nfunction spanIsSampled(span) {\n  // We align our trace flags with the ones OpenTelemetry use\n  // So we also check for sampled the same way they do.\n  const { traceFlags } = span.spanContext();\n  return traceFlags === TRACE_FLAG_SAMPLED;\n}\n\n/** Get the status message to use for a JSON representation of a span. */\nfunction getStatusMessage(status) {\n  if (!status || status.code === SPAN_STATUS_UNSET) {\n    return undefined;\n  }\n\n  if (status.code === SPAN_STATUS_OK) {\n    return 'ok';\n  }\n\n  return status.message || 'unknown_error';\n}\n\nconst CHILD_SPANS_FIELD = '_sentryChildSpans';\nconst ROOT_SPAN_FIELD = '_sentryRootSpan';\n\n/**\n * Adds an opaque child span reference to a span.\n */\nfunction addChildSpanToSpan(span, childSpan) {\n  // We store the root span reference on the child span\n  // We need this for `getRootSpan()` to work\n  const rootSpan = span[ROOT_SPAN_FIELD] || span;\n  addNonEnumerableProperty(childSpan , ROOT_SPAN_FIELD, rootSpan);\n\n  // We store a list of child spans on the parent span\n  // We need this for `getSpanDescendants()` to work\n  if (span[CHILD_SPANS_FIELD]) {\n    span[CHILD_SPANS_FIELD].add(childSpan);\n  } else {\n    addNonEnumerableProperty(span, CHILD_SPANS_FIELD, new Set([childSpan]));\n  }\n}\n\n/** This is only used internally by Idle Spans. */\nfunction removeChildSpanFromSpan(span, childSpan) {\n  if (span[CHILD_SPANS_FIELD]) {\n    span[CHILD_SPANS_FIELD].delete(childSpan);\n  }\n}\n\n/**\n * Returns an array of the given span and all of its descendants.\n */\nfunction getSpanDescendants(span) {\n  const resultSet = new Set();\n\n  function addSpanChildren(span) {\n    // This exit condition is required to not infinitely loop in case of a circular dependency.\n    if (resultSet.has(span)) {\n      return;\n      // We want to ignore unsampled spans (e.g. non recording spans)\n    } else if (spanIsSampled(span)) {\n      resultSet.add(span);\n      const childSpans = span[CHILD_SPANS_FIELD] ? Array.from(span[CHILD_SPANS_FIELD]) : [];\n      for (const childSpan of childSpans) {\n        addSpanChildren(childSpan);\n      }\n    }\n  }\n\n  addSpanChildren(span);\n\n  return Array.from(resultSet);\n}\n\n/**\n * Returns the root span of a given span.\n */\nfunction getRootSpan(span) {\n  return span[ROOT_SPAN_FIELD] || span;\n}\n\n/**\n * Returns the currently active span.\n */\nfunction getActiveSpan() {\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n  if (acs.getActiveSpan) {\n    return acs.getActiveSpan();\n  }\n\n  return _getSpanForScope(getCurrentScope());\n}\n\n/**\n * Logs a warning once if `beforeSendSpan` is used to drop spans.\n */\nfunction showSpanDropWarning() {\n  if (!hasShownSpanDropWarning) {\n    consoleSandbox(() => {\n      // eslint-disable-next-line no-console\n      console.warn(\n        '[Sentry] Returning null from `beforeSendSpan` is disallowed. To drop certain spans, configure the respective integrations directly.',\n      );\n    });\n    hasShownSpanDropWarning = true;\n  }\n}\n\n/**\n * Updates the name of the given span and ensures that the span name is not\n * overwritten by the Sentry SDK.\n *\n * Use this function instead of `span.updateName()` if you want to make sure that\n * your name is kept. For some spans, for example root `http.server` spans the\n * Sentry SDK would otherwise overwrite the span name with a high-quality name\n * it infers when the span ends.\n *\n * Use this function in server code or when your span is started on the server\n * and on the client (browser). If you only update a span name on the client,\n * you can also use `span.updateName()` the SDK does not overwrite the name.\n *\n * @param span - The span to update the name of.\n * @param name - The name to set on the span.\n */\nfunction updateSpanName(span, name) {\n  span.updateName(name);\n  span.setAttributes({\n    [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'custom',\n    [SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME]: name,\n  });\n}\n\nexport { TRACE_FLAG_NONE, TRACE_FLAG_SAMPLED, addChildSpanToSpan, convertSpanLinksForEnvelope, getActiveSpan, getRootSpan, getSpanDescendants, getStatusMessage, removeChildSpanFromSpan, showSpanDropWarning, spanIsSampled, spanTimeInputToSeconds, spanToJSON, spanToTraceContext, spanToTraceHeader, spanToTransactionTraceContext, updateSpanName };\n//# sourceMappingURL=spanUtils.js.map\n","import { getClient } from '../currentScopes.js';\n\n// Treeshakable guard to remove all code related to tracing\n\n/**\n * Determines if span recording is currently enabled.\n *\n * Spans are recorded when at least one of `tracesSampleRate` and `tracesSampler`\n * is defined in the SDK config. This function does not make any assumption about\n * sampling decisions, it only checks if the SDK is configured to record spans.\n *\n * Important: This function only determines if span recording is enabled. Trace\n * continuation and propagation is separately controlled and not covered by this function.\n * If this function returns `false`, traces can still be propagated (which is what\n * we refer to by \"Tracing without Performance\")\n * @see https://develop.sentry.dev/sdk/telemetry/traces/tracing-without-performance/\n *\n * @param maybeOptions An SDK options object to be passed to this function.\n * If this option is not provided, the function will use the current client's options.\n */\nfunction hasSpansEnabled(\n  maybeOptions,\n) {\n  if (typeof __SENTRY_TRACING__ === 'boolean' && !__SENTRY_TRACING__) {\n    return false;\n  }\n\n  const options = maybeOptions || getClient()?.getOptions();\n  return (\n    !!options &&\n    // Note: This check is `!= null`, meaning \"nullish\". `0` is not \"nullish\", `undefined` and `null` are. (This comment was brought to you by 15 minutes of questioning life)\n    (options.tracesSampleRate != null || !!options.tracesSampler)\n  );\n}\n\n/**\n * @see JSDoc of `hasSpansEnabled`\n * @deprecated Use `hasSpansEnabled` instead, which is a more accurately named version of this function.\n * This function will be removed in the next major version of the SDK.\n */\n// TODO(v10): Remove this export\nconst hasTracingEnabled = hasSpansEnabled;\n\nexport { hasSpansEnabled, hasTracingEnabled };\n//# sourceMappingURL=hasSpansEnabled.js.map\n","const DEFAULT_ENVIRONMENT = 'production';\n\nexport { DEFAULT_ENVIRONMENT };\n//# sourceMappingURL=constants.js.map\n","import { DEBUG_BUILD } from '../debug-build.js';\nimport { consoleSandbox, logger } from './logger.js';\n\n/** Regular expression used to extract org ID from a DSN host. */\nconst ORG_ID_REGEX = /^o(\\d+)\\./;\n\n/** Regular expression used to parse a Dsn. */\nconst DSN_REGEX = /^(?:(\\w+):)\\/\\/(?:(\\w+)(?::(\\w+)?)?@)([\\w.-]+)(?::(\\d+))?\\/(.+)/;\n\nfunction isValidProtocol(protocol) {\n  return protocol === 'http' || protocol === 'https';\n}\n\n/**\n * Renders the string representation of this Dsn.\n *\n * By default, this will render the public representation without the password\n * component. To get the deprecated private representation, set `withPassword`\n * to true.\n *\n * @param withPassword When set to true, the password will be included.\n */\nfunction dsnToString(dsn, withPassword = false) {\n  const { host, path, pass, port, projectId, protocol, publicKey } = dsn;\n  return (\n    `${protocol}://${publicKey}${withPassword && pass ? `:${pass}` : ''}` +\n    `@${host}${port ? `:${port}` : ''}/${path ? `${path}/` : path}${projectId}`\n  );\n}\n\n/**\n * Parses a Dsn from a given string.\n *\n * @param str A Dsn as string\n * @returns Dsn as DsnComponents or undefined if @param str is not a valid DSN string\n */\nfunction dsnFromString(str) {\n  const match = DSN_REGEX.exec(str);\n\n  if (!match) {\n    // This should be logged to the console\n    consoleSandbox(() => {\n      // eslint-disable-next-line no-console\n      console.error(`Invalid Sentry Dsn: ${str}`);\n    });\n    return undefined;\n  }\n\n  const [protocol, publicKey, pass = '', host = '', port = '', lastPath = ''] = match.slice(1);\n  let path = '';\n  let projectId = lastPath;\n\n  const split = projectId.split('/');\n  if (split.length > 1) {\n    path = split.slice(0, -1).join('/');\n    projectId = split.pop() ;\n  }\n\n  if (projectId) {\n    const projectMatch = projectId.match(/^\\d+/);\n    if (projectMatch) {\n      projectId = projectMatch[0];\n    }\n  }\n\n  return dsnFromComponents({ host, pass, path, projectId, port, protocol: protocol , publicKey });\n}\n\nfunction dsnFromComponents(components) {\n  return {\n    protocol: components.protocol,\n    publicKey: components.publicKey || '',\n    pass: components.pass || '',\n    host: components.host,\n    port: components.port || '',\n    path: components.path || '',\n    projectId: components.projectId,\n  };\n}\n\nfunction validateDsn(dsn) {\n  if (!DEBUG_BUILD) {\n    return true;\n  }\n\n  const { port, projectId, protocol } = dsn;\n\n  const requiredComponents = ['protocol', 'publicKey', 'host', 'projectId'];\n  const hasMissingRequiredComponent = requiredComponents.find(component => {\n    if (!dsn[component]) {\n      logger.error(`Invalid Sentry Dsn: ${component} missing`);\n      return true;\n    }\n    return false;\n  });\n\n  if (hasMissingRequiredComponent) {\n    return false;\n  }\n\n  if (!projectId.match(/^\\d+$/)) {\n    logger.error(`Invalid Sentry Dsn: Invalid projectId ${projectId}`);\n    return false;\n  }\n\n  if (!isValidProtocol(protocol)) {\n    logger.error(`Invalid Sentry Dsn: Invalid protocol ${protocol}`);\n    return false;\n  }\n\n  if (port && isNaN(parseInt(port, 10))) {\n    logger.error(`Invalid Sentry Dsn: Invalid port ${port}`);\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Extract the org ID from a DSN host.\n *\n * @param host The host from a DSN\n * @returns The org ID if found, undefined otherwise\n */\nfunction extractOrgIdFromDsnHost(host) {\n  const match = host.match(ORG_ID_REGEX);\n\n  return match?.[1];\n}\n\n/**\n * Creates a valid Sentry Dsn object, identifying a Sentry instance and project.\n * @returns a valid DsnComponents object or `undefined` if @param from is an invalid DSN source\n */\nfunction makeDsn(from) {\n  const components = typeof from === 'string' ? dsnFromString(from) : dsnFromComponents(from);\n  if (!components || !validateDsn(components)) {\n    return undefined;\n  }\n  return components;\n}\n\nexport { dsnFromString, dsnToString, extractOrgIdFromDsnHost, makeDsn };\n//# sourceMappingURL=dsn.js.map\n","import { DEFAULT_ENVIRONMENT } from '../constants.js';\nimport { getClient } from '../currentScopes.js';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE, SEMANTIC_ATTRIBUTE_SENTRY_PREVIOUS_TRACE_SAMPLE_RATE, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE } from '../semanticAttributes.js';\nimport { baggageHeaderToDynamicSamplingContext, dynamicSamplingContextToSentryBaggageHeader } from '../utils/baggage.js';\nimport { extractOrgIdFromDsnHost } from '../utils/dsn.js';\nimport { hasSpansEnabled } from '../utils/hasSpansEnabled.js';\nimport { addNonEnumerableProperty } from '../utils/object.js';\nimport { getRootSpan, spanToJSON, spanIsSampled } from '../utils/spanUtils.js';\nimport { getCapturedScopesOnSpan } from './utils.js';\n\n/**\n * If you change this value, also update the terser plugin config to\n * avoid minification of the object property!\n */\nconst FROZEN_DSC_FIELD = '_frozenDsc';\n\n/**\n * Freeze the given DSC on the given span.\n */\nfunction freezeDscOnSpan(span, dsc) {\n  const spanWithMaybeDsc = span ;\n  addNonEnumerableProperty(spanWithMaybeDsc, FROZEN_DSC_FIELD, dsc);\n}\n\n/**\n * Creates a dynamic sampling context from a client.\n *\n * Dispatches the `createDsc` lifecycle hook as a side effect.\n */\nfunction getDynamicSamplingContextFromClient(trace_id, client) {\n  const options = client.getOptions();\n\n  const { publicKey: public_key, host } = client.getDsn() || {};\n\n  let org_id;\n  if (options.orgId) {\n    org_id = String(options.orgId);\n  } else if (host) {\n    org_id = extractOrgIdFromDsnHost(host);\n  }\n\n  // Instead of conditionally adding non-undefined values, we add them and then remove them if needed\n  // otherwise, the order of baggage entries changes, which \"breaks\" a bunch of tests etc.\n  const dsc = {\n    environment: options.environment || DEFAULT_ENVIRONMENT,\n    release: options.release,\n    public_key,\n    trace_id,\n    org_id,\n  };\n\n  client.emit('createDsc', dsc);\n\n  return dsc;\n}\n\n/**\n * Get the dynamic sampling context for the currently active scopes.\n */\nfunction getDynamicSamplingContextFromScope(client, scope) {\n  const propagationContext = scope.getPropagationContext();\n  return propagationContext.dsc || getDynamicSamplingContextFromClient(propagationContext.traceId, client);\n}\n\n/**\n * Creates a dynamic sampling context from a span (and client and scope)\n *\n * @param span the span from which a few values like the root span name and sample rate are extracted.\n *\n * @returns a dynamic sampling context\n */\nfunction getDynamicSamplingContextFromSpan(span) {\n  const client = getClient();\n  if (!client) {\n    return {};\n  }\n\n  const rootSpan = getRootSpan(span);\n  const rootSpanJson = spanToJSON(rootSpan);\n  const rootSpanAttributes = rootSpanJson.data;\n  const traceState = rootSpan.spanContext().traceState;\n\n  // The span sample rate that was locally applied to the root span should also always be applied to the DSC, even if the DSC is frozen.\n  // This is so that the downstream traces/services can use parentSampleRate in their `tracesSampler` to make consistent sampling decisions across the entire trace.\n  const rootSpanSampleRate =\n    traceState?.get('sentry.sample_rate') ??\n    rootSpanAttributes[SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE] ??\n    rootSpanAttributes[SEMANTIC_ATTRIBUTE_SENTRY_PREVIOUS_TRACE_SAMPLE_RATE];\n\n  function applyLocalSampleRateToDsc(dsc) {\n    if (typeof rootSpanSampleRate === 'number' || typeof rootSpanSampleRate === 'string') {\n      dsc.sample_rate = `${rootSpanSampleRate}`;\n    }\n    return dsc;\n  }\n\n  // For core implementation, we freeze the DSC onto the span as a non-enumerable property\n  const frozenDsc = (rootSpan )[FROZEN_DSC_FIELD];\n  if (frozenDsc) {\n    return applyLocalSampleRateToDsc(frozenDsc);\n  }\n\n  // For OpenTelemetry, we freeze the DSC on the trace state\n  const traceStateDsc = traceState?.get('sentry.dsc');\n\n  // If the span has a DSC, we want it to take precedence\n  const dscOnTraceState = traceStateDsc && baggageHeaderToDynamicSamplingContext(traceStateDsc);\n\n  if (dscOnTraceState) {\n    return applyLocalSampleRateToDsc(dscOnTraceState);\n  }\n\n  // Else, we generate it from the span\n  const dsc = getDynamicSamplingContextFromClient(span.spanContext().traceId, client);\n\n  // We don't want to have a transaction name in the DSC if the source is \"url\" because URLs might contain PII\n  const source = rootSpanAttributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n\n  // after JSON conversion, txn.name becomes jsonSpan.description\n  const name = rootSpanJson.description;\n  if (source !== 'url' && name) {\n    dsc.transaction = name;\n  }\n\n  // How can we even land here with hasSpansEnabled() returning false?\n  // Otel creates a Non-recording span in Tracing Without Performance mode when handling incoming requests\n  // So we end up with an active span that is not sampled (neither positively nor negatively)\n  if (hasSpansEnabled()) {\n    dsc.sampled = String(spanIsSampled(rootSpan));\n    dsc.sample_rand =\n      // In OTEL we store the sample rand on the trace state because we cannot access scopes for NonRecordingSpans\n      // The Sentry OTEL SpanSampler takes care of writing the sample rand on the root span\n      traceState?.get('sentry.sample_rand') ??\n      // On all other platforms we can actually get the scopes from a root span (we use this as a fallback)\n      getCapturedScopesOnSpan(rootSpan).scope?.getPropagationContext().sampleRand.toString();\n  }\n\n  applyLocalSampleRateToDsc(dsc);\n\n  client.emit('createDsc', dsc, rootSpan);\n\n  return dsc;\n}\n\n/**\n * Convert a Span to a baggage header.\n */\nfunction spanToBaggageHeader(span) {\n  const dsc = getDynamicSamplingContextFromSpan(span);\n  return dynamicSamplingContextToSentryBaggageHeader(dsc);\n}\n\nexport { freezeDscOnSpan, getDynamicSamplingContextFromClient, getDynamicSamplingContextFromScope, getDynamicSamplingContextFromSpan, spanToBaggageHeader };\n//# sourceMappingURL=dynamicSamplingContext.js.map\n","import { isVueViewModel, isSyntheticEvent } from './is.js';\nimport { convertToPlainObject } from './object.js';\nimport { getFunctionName } from './stacktrace.js';\n\n/**\n * Recursively normalizes the given object.\n *\n * - Creates a copy to prevent original input mutation\n * - Skips non-enumerable properties\n * - When stringifying, calls `toJSON` if implemented\n * - Removes circular references\n * - Translates non-serializable values (`undefined`/`NaN`/functions) to serializable format\n * - Translates known global objects/classes to a string representations\n * - Takes care of `Error` object serialization\n * - Optionally limits depth of final output\n * - Optionally limits number of properties/elements included in any single object/array\n *\n * @param input The object to be normalized.\n * @param depth The max depth to which to normalize the object. (Anything deeper stringified whole.)\n * @param maxProperties The max number of elements or properties to be included in any single array or\n * object in the normalized output.\n * @returns A normalized version of the object, or `\"**non-serializable**\"` if any errors are thrown during normalization.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction normalize(input, depth = 100, maxProperties = +Infinity) {\n  try {\n    // since we're at the outermost level, we don't provide a key\n    return visit('', input, depth, maxProperties);\n  } catch (err) {\n    return { ERROR: `**non-serializable** (${err})` };\n  }\n}\n\n/** JSDoc */\nfunction normalizeToSize(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  object,\n  // Default Node.js REPL depth\n  depth = 3,\n  // 100kB, as 200kB is max payload size, so half sounds reasonable\n  maxSize = 100 * 1024,\n) {\n  const normalized = normalize(object, depth);\n\n  if (jsonSize(normalized) > maxSize) {\n    return normalizeToSize(object, depth - 1, maxSize);\n  }\n\n  return normalized ;\n}\n\n/**\n * Visits a node to perform normalization on it\n *\n * @param key The key corresponding to the given node\n * @param value The node to be visited\n * @param depth Optional number indicating the maximum recursion depth\n * @param maxProperties Optional maximum number of properties/elements included in any single object/array\n * @param memo Optional Memo class handling decycling\n */\nfunction visit(\n  key,\n  value,\n  depth = +Infinity,\n  maxProperties = +Infinity,\n  memo = memoBuilder(),\n) {\n  const [memoize, unmemoize] = memo;\n\n  // Get the simple cases out of the way first\n  if (\n    value == null || // this matches null and undefined -> eqeq not eqeqeq\n    ['boolean', 'string'].includes(typeof value) ||\n    (typeof value === 'number' && Number.isFinite(value))\n  ) {\n    return value ;\n  }\n\n  const stringified = stringifyValue(key, value);\n\n  // Anything we could potentially dig into more (objects or arrays) will have come back as `\"[object XXXX]\"`.\n  // Everything else will have already been serialized, so if we don't see that pattern, we're done.\n  if (!stringified.startsWith('[object ')) {\n    return stringified;\n  }\n\n  // From here on, we can assert that `value` is either an object or an array.\n\n  // Do not normalize objects that we know have already been normalized. As a general rule, the\n  // \"__sentry_skip_normalization__\" property should only be used sparingly and only should only be set on objects that\n  // have already been normalized.\n  if ((value )['__sentry_skip_normalization__']) {\n    return value ;\n  }\n\n  // We can set `__sentry_override_normalization_depth__` on an object to ensure that from there\n  // We keep a certain amount of depth.\n  // This should be used sparingly, e.g. we use it for the redux integration to ensure we get a certain amount of state.\n  const remainingDepth =\n    typeof (value )['__sentry_override_normalization_depth__'] === 'number'\n      ? ((value )['__sentry_override_normalization_depth__'] )\n      : depth;\n\n  // We're also done if we've reached the max depth\n  if (remainingDepth === 0) {\n    // At this point we know `serialized` is a string of the form `\"[object XXXX]\"`. Clean it up so it's just `\"[XXXX]\"`.\n    return stringified.replace('object ', '');\n  }\n\n  // If we've already visited this branch, bail out, as it's circular reference. If not, note that we're seeing it now.\n  if (memoize(value)) {\n    return '[Circular ~]';\n  }\n\n  // If the value has a `toJSON` method, we call it to extract more information\n  const valueWithToJSON = value ;\n  if (valueWithToJSON && typeof valueWithToJSON.toJSON === 'function') {\n    try {\n      const jsonValue = valueWithToJSON.toJSON();\n      // We need to normalize the return value of `.toJSON()` in case it has circular references\n      return visit('', jsonValue, remainingDepth - 1, maxProperties, memo);\n    } catch (err) {\n      // pass (The built-in `toJSON` failed, but we can still try to do it ourselves)\n    }\n  }\n\n  // At this point we know we either have an object or an array, we haven't seen it before, and we're going to recurse\n  // because we haven't yet reached the max depth. Create an accumulator to hold the results of visiting each\n  // property/entry, and keep track of the number of items we add to it.\n  const normalized = (Array.isArray(value) ? [] : {}) ;\n  let numAdded = 0;\n\n  // Before we begin, convert`Error` and`Event` instances into plain objects, since some of each of their relevant\n  // properties are non-enumerable and otherwise would get missed.\n  const visitable = convertToPlainObject(value );\n\n  for (const visitKey in visitable) {\n    // Avoid iterating over fields in the prototype if they've somehow been exposed to enumeration.\n    if (!Object.prototype.hasOwnProperty.call(visitable, visitKey)) {\n      continue;\n    }\n\n    if (numAdded >= maxProperties) {\n      normalized[visitKey] = '[MaxProperties ~]';\n      break;\n    }\n\n    // Recursively visit all the child nodes\n    const visitValue = visitable[visitKey];\n    normalized[visitKey] = visit(visitKey, visitValue, remainingDepth - 1, maxProperties, memo);\n\n    numAdded++;\n  }\n\n  // Once we've visited all the branches, remove the parent from memo storage\n  unmemoize(value);\n\n  // Return accumulated values\n  return normalized;\n}\n\n/* eslint-disable complexity */\n/**\n * Stringify the given value. Handles various known special values and types.\n *\n * Not meant to be used on simple primitives which already have a string representation, as it will, for example, turn\n * the number 1231 into \"[Object Number]\", nor on `null`, as it will throw.\n *\n * @param value The value to stringify\n * @returns A stringified representation of the given value\n */\nfunction stringifyValue(\n  key,\n  // this type is a tiny bit of a cheat, since this function does handle NaN (which is technically a number), but for\n  // our internal use, it'll do\n  value,\n) {\n  try {\n    if (key === 'domain' && value && typeof value === 'object' && (value )._events) {\n      return '[Domain]';\n    }\n\n    if (key === 'domainEmitter') {\n      return '[DomainEmitter]';\n    }\n\n    // It's safe to use `global`, `window`, and `document` here in this manner, as we are asserting using `typeof` first\n    // which won't throw if they are not present.\n\n    if (typeof global !== 'undefined' && value === global) {\n      return '[Global]';\n    }\n\n    // eslint-disable-next-line no-restricted-globals\n    if (typeof window !== 'undefined' && value === window) {\n      return '[Window]';\n    }\n\n    // eslint-disable-next-line no-restricted-globals\n    if (typeof document !== 'undefined' && value === document) {\n      return '[Document]';\n    }\n\n    if (isVueViewModel(value)) {\n      return '[VueViewModel]';\n    }\n\n    // React's SyntheticEvent thingy\n    if (isSyntheticEvent(value)) {\n      return '[SyntheticEvent]';\n    }\n\n    if (typeof value === 'number' && !Number.isFinite(value)) {\n      return `[${value}]`;\n    }\n\n    if (typeof value === 'function') {\n      return `[Function: ${getFunctionName(value)}]`;\n    }\n\n    if (typeof value === 'symbol') {\n      return `[${String(value)}]`;\n    }\n\n    // stringified BigInts are indistinguishable from regular numbers, so we need to label them to avoid confusion\n    if (typeof value === 'bigint') {\n      return `[BigInt: ${String(value)}]`;\n    }\n\n    // Now that we've knocked out all the special cases and the primitives, all we have left are objects. Simply casting\n    // them to strings means that instances of classes which haven't defined their `toStringTag` will just come out as\n    // `\"[object Object]\"`. If we instead look at the constructor's name (which is the same as the name of the class),\n    // we can make sure that only plain objects come out that way.\n    const objName = getConstructorName(value);\n\n    // Handle HTML Elements\n    if (/^HTML(\\w*)Element$/.test(objName)) {\n      return `[HTMLElement: ${objName}]`;\n    }\n\n    return `[object ${objName}]`;\n  } catch (err) {\n    return `**non-serializable** (${err})`;\n  }\n}\n/* eslint-enable complexity */\n\nfunction getConstructorName(value) {\n  const prototype = Object.getPrototypeOf(value);\n\n  return prototype?.constructor ? prototype.constructor.name : 'null prototype';\n}\n\n/** Calculates bytes size of input string */\nfunction utf8Length(value) {\n  // eslint-disable-next-line no-bitwise\n  return ~-encodeURI(value).split(/%..|./).length;\n}\n\n/** Calculates bytes size of input object */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction jsonSize(value) {\n  return utf8Length(JSON.stringify(value));\n}\n\n/**\n * Normalizes URLs in exceptions and stacktraces to a base path so Sentry can fingerprint\n * across platforms and working directory.\n *\n * @param url The URL to be normalized.\n * @param basePath The application base path.\n * @returns The normalized URL.\n */\nfunction normalizeUrlToBase(url, basePath) {\n  const escapedBase = basePath\n    // Backslash to forward\n    .replace(/\\\\/g, '/')\n    // Escape RegExp special characters\n    .replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&');\n\n  let newUrl = url;\n  try {\n    newUrl = decodeURI(url);\n  } catch (_Oo) {\n    // Sometime this breaks\n  }\n  return (\n    newUrl\n      .replace(/\\\\/g, '/')\n      .replace(/webpack:\\/?/g, '') // Remove intermediate base path\n      // eslint-disable-next-line @sentry-internal/sdk/no-regexp-constructor\n      .replace(new RegExp(`(file://)?/*${escapedBase}/*`, 'ig'), 'app:///')\n  );\n}\n\n/**\n * Helper to decycle json objects\n */\nfunction memoBuilder() {\n  const inner = new WeakSet();\n  function memoize(obj) {\n    if (inner.has(obj)) {\n      return true;\n    }\n    inner.add(obj);\n    return false;\n  }\n\n  function unmemoize(obj) {\n    inner.delete(obj);\n  }\n  return [memoize, unmemoize];\n}\n\nexport { normalize, normalizeToSize, normalizeUrlToBase };\n//# sourceMappingURL=normalize.js.map\n","import { isThenable } from './is.js';\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/** SyncPromise internal states */\nvar States; (function (States) {\n  /** Pending */\n  const PENDING = 0; States[States[\"PENDING\"] = PENDING] = \"PENDING\";\n  /** Resolved / OK */\n  const RESOLVED = 1; States[States[\"RESOLVED\"] = RESOLVED] = \"RESOLVED\";\n  /** Rejected / Error */\n  const REJECTED = 2; States[States[\"REJECTED\"] = REJECTED] = \"REJECTED\";\n})(States || (States = {}));\n\n// Overloads so we can call resolvedSyncPromise without arguments and generic argument\n\n/**\n * Creates a resolved sync promise.\n *\n * @param value the value to resolve the promise with\n * @returns the resolved sync promise\n */\nfunction resolvedSyncPromise(value) {\n  return new SyncPromise(resolve => {\n    resolve(value);\n  });\n}\n\n/**\n * Creates a rejected sync promise.\n *\n * @param value the value to reject the promise with\n * @returns the rejected sync promise\n */\nfunction rejectedSyncPromise(reason) {\n  return new SyncPromise((_, reject) => {\n    reject(reason);\n  });\n}\n\n/**\n * Thenable class that behaves like a Promise and follows it's interface\n * but is not async internally\n */\nclass SyncPromise {\n\n   constructor(executor) {\n    this._state = States.PENDING;\n    this._handlers = [];\n\n    this._runExecutor(executor);\n  }\n\n  /** @inheritdoc */\n   then(\n    onfulfilled,\n    onrejected,\n  ) {\n    return new SyncPromise((resolve, reject) => {\n      this._handlers.push([\n        false,\n        result => {\n          if (!onfulfilled) {\n            // TODO: \\_()_/\n            // TODO: FIXME\n            resolve(result );\n          } else {\n            try {\n              resolve(onfulfilled(result));\n            } catch (e) {\n              reject(e);\n            }\n          }\n        },\n        reason => {\n          if (!onrejected) {\n            reject(reason);\n          } else {\n            try {\n              resolve(onrejected(reason));\n            } catch (e) {\n              reject(e);\n            }\n          }\n        },\n      ]);\n      this._executeHandlers();\n    });\n  }\n\n  /** @inheritdoc */\n   catch(\n    onrejected,\n  ) {\n    return this.then(val => val, onrejected);\n  }\n\n  /** @inheritdoc */\n   finally(onfinally) {\n    return new SyncPromise((resolve, reject) => {\n      let val;\n      let isRejected;\n\n      return this.then(\n        value => {\n          isRejected = false;\n          val = value;\n          if (onfinally) {\n            onfinally();\n          }\n        },\n        reason => {\n          isRejected = true;\n          val = reason;\n          if (onfinally) {\n            onfinally();\n          }\n        },\n      ).then(() => {\n        if (isRejected) {\n          reject(val);\n          return;\n        }\n\n        resolve(val );\n      });\n    });\n  }\n\n  /** Excute the resolve/reject handlers. */\n   _executeHandlers() {\n    if (this._state === States.PENDING) {\n      return;\n    }\n\n    const cachedHandlers = this._handlers.slice();\n    this._handlers = [];\n\n    cachedHandlers.forEach(handler => {\n      if (handler[0]) {\n        return;\n      }\n\n      if (this._state === States.RESOLVED) {\n        handler[1](this._value );\n      }\n\n      if (this._state === States.REJECTED) {\n        handler[2](this._value);\n      }\n\n      handler[0] = true;\n    });\n  }\n\n  /** Run the executor for the SyncPromise. */\n   _runExecutor(executor) {\n    const setResult = (state, value) => {\n      if (this._state !== States.PENDING) {\n        return;\n      }\n\n      if (isThenable(value)) {\n        void (value ).then(resolve, reject);\n        return;\n      }\n\n      this._state = state;\n      this._value = value;\n\n      this._executeHandlers();\n    };\n\n    const resolve = (value) => {\n      setResult(States.RESOLVED, value);\n    };\n\n    const reject = (reason) => {\n      setResult(States.REJECTED, reason);\n    };\n\n    try {\n      executor(resolve, reject);\n    } catch (e) {\n      reject(e);\n    }\n  }\n}\n\nexport { SyncPromise, rejectedSyncPromise, resolvedSyncPromise };\n//# sourceMappingURL=syncpromise.js.map\n","import { DEBUG_BUILD } from './debug-build.js';\nimport { isThenable } from './utils/is.js';\nimport { logger } from './utils/logger.js';\nimport { SyncPromise } from './utils/syncpromise.js';\n\n/**\n * Process an array of event processors, returning the processed event (or `null` if the event was dropped).\n */\nfunction notifyEventProcessors(\n  processors,\n  event,\n  hint,\n  index = 0,\n) {\n  return new SyncPromise((resolve, reject) => {\n    const processor = processors[index];\n    if (event === null || typeof processor !== 'function') {\n      resolve(event);\n    } else {\n      const result = processor({ ...event }, hint) ;\n\n      DEBUG_BUILD && processor.id && result === null && logger.log(`Event processor \"${processor.id}\" dropped event`);\n\n      if (isThenable(result)) {\n        void result\n          .then(final => notifyEventProcessors(processors, final, hint, index + 1).then(resolve))\n          .then(null, reject);\n      } else {\n        void notifyEventProcessors(processors, result, hint, index + 1)\n          .then(resolve)\n          .then(null, reject);\n      }\n    }\n  });\n}\n\nexport { notifyEventProcessors };\n//# sourceMappingURL=eventProcessors.js.map\n","import { getDynamicSamplingContextFromSpan } from '../tracing/dynamicSamplingContext.js';\nimport { merge } from './merge.js';\nimport { spanToTraceContext, getRootSpan, spanToJSON } from './spanUtils.js';\n\n/**\n * Applies data from the scope to the event and runs all event processors on it.\n */\nfunction applyScopeDataToEvent(event, data) {\n  const { fingerprint, span, breadcrumbs, sdkProcessingMetadata } = data;\n\n  // Apply general data\n  applyDataToEvent(event, data);\n\n  // We want to set the trace context for normal events only if there isn't already\n  // a trace context on the event. There is a product feature in place where we link\n  // errors with transaction and it relies on that.\n  if (span) {\n    applySpanToEvent(event, span);\n  }\n\n  applyFingerprintToEvent(event, fingerprint);\n  applyBreadcrumbsToEvent(event, breadcrumbs);\n  applySdkMetadataToEvent(event, sdkProcessingMetadata);\n}\n\n/** Merge data of two scopes together. */\nfunction mergeScopeData(data, mergeData) {\n  const {\n    extra,\n    tags,\n    user,\n    contexts,\n    level,\n    sdkProcessingMetadata,\n    breadcrumbs,\n    fingerprint,\n    eventProcessors,\n    attachments,\n    propagationContext,\n    transactionName,\n    span,\n  } = mergeData;\n\n  mergeAndOverwriteScopeData(data, 'extra', extra);\n  mergeAndOverwriteScopeData(data, 'tags', tags);\n  mergeAndOverwriteScopeData(data, 'user', user);\n  mergeAndOverwriteScopeData(data, 'contexts', contexts);\n\n  data.sdkProcessingMetadata = merge(data.sdkProcessingMetadata, sdkProcessingMetadata, 2);\n\n  if (level) {\n    data.level = level;\n  }\n\n  if (transactionName) {\n    data.transactionName = transactionName;\n  }\n\n  if (span) {\n    data.span = span;\n  }\n\n  if (breadcrumbs.length) {\n    data.breadcrumbs = [...data.breadcrumbs, ...breadcrumbs];\n  }\n\n  if (fingerprint.length) {\n    data.fingerprint = [...data.fingerprint, ...fingerprint];\n  }\n\n  if (eventProcessors.length) {\n    data.eventProcessors = [...data.eventProcessors, ...eventProcessors];\n  }\n\n  if (attachments.length) {\n    data.attachments = [...data.attachments, ...attachments];\n  }\n\n  data.propagationContext = { ...data.propagationContext, ...propagationContext };\n}\n\n/**\n * Merges certain scope data. Undefined values will overwrite any existing values.\n * Exported only for tests.\n */\nfunction mergeAndOverwriteScopeData\n\n(data, prop, mergeVal) {\n  data[prop] = merge(data[prop], mergeVal, 1);\n}\n\nfunction applyDataToEvent(event, data) {\n  const { extra, tags, user, contexts, level, transactionName } = data;\n\n  if (Object.keys(extra).length) {\n    event.extra = { ...extra, ...event.extra };\n  }\n\n  if (Object.keys(tags).length) {\n    event.tags = { ...tags, ...event.tags };\n  }\n\n  if (Object.keys(user).length) {\n    event.user = { ...user, ...event.user };\n  }\n\n  if (Object.keys(contexts).length) {\n    event.contexts = { ...contexts, ...event.contexts };\n  }\n\n  if (level) {\n    event.level = level;\n  }\n\n  // transaction events get their `transaction` from the root span name\n  if (transactionName && event.type !== 'transaction') {\n    event.transaction = transactionName;\n  }\n}\n\nfunction applyBreadcrumbsToEvent(event, breadcrumbs) {\n  const mergedBreadcrumbs = [...(event.breadcrumbs || []), ...breadcrumbs];\n  event.breadcrumbs = mergedBreadcrumbs.length ? mergedBreadcrumbs : undefined;\n}\n\nfunction applySdkMetadataToEvent(event, sdkProcessingMetadata) {\n  event.sdkProcessingMetadata = {\n    ...event.sdkProcessingMetadata,\n    ...sdkProcessingMetadata,\n  };\n}\n\nfunction applySpanToEvent(event, span) {\n  event.contexts = {\n    trace: spanToTraceContext(span),\n    ...event.contexts,\n  };\n\n  event.sdkProcessingMetadata = {\n    dynamicSamplingContext: getDynamicSamplingContextFromSpan(span),\n    ...event.sdkProcessingMetadata,\n  };\n\n  const rootSpan = getRootSpan(span);\n  const transactionName = spanToJSON(rootSpan).description;\n  if (transactionName && !event.transaction && event.type === 'transaction') {\n    event.transaction = transactionName;\n  }\n}\n\n/**\n * Applies fingerprint from the scope to the event if there's one,\n * uses message if there's one instead or get rid of empty fingerprint\n */\nfunction applyFingerprintToEvent(event, fingerprint) {\n  // Make sure it's an array first and we actually have something in place\n  event.fingerprint = event.fingerprint\n    ? Array.isArray(event.fingerprint)\n      ? event.fingerprint\n      : [event.fingerprint]\n    : [];\n\n  // If we have something on the scope, then merge it with event\n  if (fingerprint) {\n    event.fingerprint = event.fingerprint.concat(fingerprint);\n  }\n\n  // If we have no data at all, remove empty array default\n  if (!event.fingerprint.length) {\n    delete event.fingerprint;\n  }\n}\n\nexport { applyScopeDataToEvent, mergeAndOverwriteScopeData, mergeScopeData };\n//# sourceMappingURL=applyScopeDataToEvent.js.map\n","import { GLOBAL_OBJ } from './worldwide.js';\n\nlet parsedStackResults;\nlet lastKeysCount;\nlet cachedFilenameDebugIds;\n\n/**\n * Returns a map of filenames to debug identifiers.\n */\nfunction getFilenameToDebugIdMap(stackParser) {\n  const debugIdMap = GLOBAL_OBJ._sentryDebugIds;\n  if (!debugIdMap) {\n    return {};\n  }\n\n  const debugIdKeys = Object.keys(debugIdMap);\n\n  // If the count of registered globals hasn't changed since the last call, we\n  // can just return the cached result.\n  if (cachedFilenameDebugIds && debugIdKeys.length === lastKeysCount) {\n    return cachedFilenameDebugIds;\n  }\n\n  lastKeysCount = debugIdKeys.length;\n\n  // Build a map of filename -> debug_id.\n  cachedFilenameDebugIds = debugIdKeys.reduce((acc, stackKey) => {\n    if (!parsedStackResults) {\n      parsedStackResults = {};\n    }\n\n    const result = parsedStackResults[stackKey];\n\n    if (result) {\n      acc[result[0]] = result[1];\n    } else {\n      const parsedStack = stackParser(stackKey);\n\n      for (let i = parsedStack.length - 1; i >= 0; i--) {\n        const stackFrame = parsedStack[i];\n        const filename = stackFrame?.filename;\n        const debugId = debugIdMap[stackKey];\n\n        if (filename && debugId) {\n          acc[filename] = debugId;\n          parsedStackResults[stackKey] = [filename, debugId];\n          break;\n        }\n      }\n    }\n\n    return acc;\n  }, {});\n\n  return cachedFilenameDebugIds;\n}\n\n/**\n * Returns a list of debug images for the given resources.\n */\nfunction getDebugImagesForResources(\n  stackParser,\n  resource_paths,\n) {\n  const filenameDebugIdMap = getFilenameToDebugIdMap(stackParser);\n\n  if (!filenameDebugIdMap) {\n    return [];\n  }\n\n  const images = [];\n  for (const path of resource_paths) {\n    if (path && filenameDebugIdMap[path]) {\n      images.push({\n        type: 'sourcemap',\n        code_file: path,\n        debug_id: filenameDebugIdMap[path] ,\n      });\n    }\n  }\n\n  return images;\n}\n\nexport { getDebugImagesForResources, getFilenameToDebugIdMap };\n//# sourceMappingURL=debug-ids.js.map\n","import { DEFAULT_ENVIRONMENT } from '../constants.js';\nimport { getGlobalScope } from '../currentScopes.js';\nimport { notifyEventProcessors } from '../eventProcessors.js';\nimport { Scope } from '../scope.js';\nimport { mergeScopeData, applyScopeDataToEvent } from './applyScopeDataToEvent.js';\nimport { getFilenameToDebugIdMap } from './debug-ids.js';\nimport { uuid4, addExceptionMechanism } from './misc.js';\nimport { normalize } from './normalize.js';\nimport { truncate } from './string.js';\nimport { dateTimestampInSeconds } from './time.js';\n\n/**\n * This type makes sure that we get either a CaptureContext, OR an EventHint.\n * It does not allow mixing them, which could lead to unexpected outcomes, e.g. this is disallowed:\n * { user: { id: '123' }, mechanism: { handled: false } }\n */\n\n/**\n * Adds common information to events.\n *\n * The information includes release and environment from `options`,\n * breadcrumbs and context (extra, tags and user) from the scope.\n *\n * Information that is already present in the event is never overwritten. For\n * nested objects, such as the context, keys are merged.\n *\n * @param event The original event.\n * @param hint May contain additional information about the original exception.\n * @param scope A scope containing event metadata.\n * @returns A new event with more information.\n * @hidden\n */\nfunction prepareEvent(\n  options,\n  event,\n  hint,\n  scope,\n  client,\n  isolationScope,\n) {\n  const { normalizeDepth = 3, normalizeMaxBreadth = 1000 } = options;\n  const prepared = {\n    ...event,\n    event_id: event.event_id || hint.event_id || uuid4(),\n    timestamp: event.timestamp || dateTimestampInSeconds(),\n  };\n  const integrations = hint.integrations || options.integrations.map(i => i.name);\n\n  applyClientOptions(prepared, options);\n  applyIntegrationsMetadata(prepared, integrations);\n\n  if (client) {\n    client.emit('applyFrameMetadata', event);\n  }\n\n  // Only put debug IDs onto frames for error events.\n  if (event.type === undefined) {\n    applyDebugIds(prepared, options.stackParser);\n  }\n\n  // If we have scope given to us, use it as the base for further modifications.\n  // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.\n  const finalScope = getFinalScope(scope, hint.captureContext);\n\n  if (hint.mechanism) {\n    addExceptionMechanism(prepared, hint.mechanism);\n  }\n\n  const clientEventProcessors = client ? client.getEventProcessors() : [];\n\n  // This should be the last thing called, since we want that\n  // {@link Scope.addEventProcessor} gets the finished prepared event.\n  // Merge scope data together\n  const data = getGlobalScope().getScopeData();\n\n  if (isolationScope) {\n    const isolationData = isolationScope.getScopeData();\n    mergeScopeData(data, isolationData);\n  }\n\n  if (finalScope) {\n    const finalScopeData = finalScope.getScopeData();\n    mergeScopeData(data, finalScopeData);\n  }\n\n  const attachments = [...(hint.attachments || []), ...data.attachments];\n  if (attachments.length) {\n    hint.attachments = attachments;\n  }\n\n  applyScopeDataToEvent(prepared, data);\n\n  const eventProcessors = [\n    ...clientEventProcessors,\n    // Run scope event processors _after_ all other processors\n    ...data.eventProcessors,\n  ];\n\n  const result = notifyEventProcessors(eventProcessors, prepared, hint);\n\n  return result.then(evt => {\n    if (evt) {\n      // We apply the debug_meta field only after all event processors have ran, so that if any event processors modified\n      // file names (e.g.the RewriteFrames integration) the filename -> debug ID relationship isn't destroyed.\n      // This should not cause any PII issues, since we're only moving data that is already on the event and not adding\n      // any new data\n      applyDebugMeta(evt);\n    }\n\n    if (typeof normalizeDepth === 'number' && normalizeDepth > 0) {\n      return normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);\n    }\n    return evt;\n  });\n}\n\n/**\n * Enhances event using the client configuration.\n * It takes care of all \"static\" values like environment, release and `dist`,\n * as well as truncating overly long values.\n *\n * Only exported for tests.\n *\n * @param event event instance to be enhanced\n */\nfunction applyClientOptions(event, options) {\n  const { environment, release, dist, maxValueLength = 250 } = options;\n\n  // empty strings do not make sense for environment, release, and dist\n  // so we handle them the same as if they were not provided\n  event.environment = event.environment || environment || DEFAULT_ENVIRONMENT;\n\n  if (!event.release && release) {\n    event.release = release;\n  }\n\n  if (!event.dist && dist) {\n    event.dist = dist;\n  }\n\n  const request = event.request;\n  if (request?.url) {\n    request.url = truncate(request.url, maxValueLength);\n  }\n}\n\n/**\n * Puts debug IDs into the stack frames of an error event.\n */\nfunction applyDebugIds(event, stackParser) {\n  // Build a map of filename -> debug_id\n  const filenameDebugIdMap = getFilenameToDebugIdMap(stackParser);\n\n  event.exception?.values?.forEach(exception => {\n    exception.stacktrace?.frames?.forEach(frame => {\n      if (frame.filename) {\n        frame.debug_id = filenameDebugIdMap[frame.filename];\n      }\n    });\n  });\n}\n\n/**\n * Moves debug IDs from the stack frames of an error event into the debug_meta field.\n */\nfunction applyDebugMeta(event) {\n  // Extract debug IDs and filenames from the stack frames on the event.\n  const filenameDebugIdMap = {};\n  event.exception?.values?.forEach(exception => {\n    exception.stacktrace?.frames?.forEach(frame => {\n      if (frame.debug_id) {\n        if (frame.abs_path) {\n          filenameDebugIdMap[frame.abs_path] = frame.debug_id;\n        } else if (frame.filename) {\n          filenameDebugIdMap[frame.filename] = frame.debug_id;\n        }\n        delete frame.debug_id;\n      }\n    });\n  });\n\n  if (Object.keys(filenameDebugIdMap).length === 0) {\n    return;\n  }\n\n  // Fill debug_meta information\n  event.debug_meta = event.debug_meta || {};\n  event.debug_meta.images = event.debug_meta.images || [];\n  const images = event.debug_meta.images;\n  Object.entries(filenameDebugIdMap).forEach(([filename, debug_id]) => {\n    images.push({\n      type: 'sourcemap',\n      code_file: filename,\n      debug_id,\n    });\n  });\n}\n\n/**\n * This function adds all used integrations to the SDK info in the event.\n * @param event The event that will be filled with all integrations.\n */\nfunction applyIntegrationsMetadata(event, integrationNames) {\n  if (integrationNames.length > 0) {\n    event.sdk = event.sdk || {};\n    event.sdk.integrations = [...(event.sdk.integrations || []), ...integrationNames];\n  }\n}\n\n/**\n * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.\n * Normalized keys:\n * - `breadcrumbs.data`\n * - `user`\n * - `contexts`\n * - `extra`\n * @param event Event\n * @returns Normalized event\n */\nfunction normalizeEvent(event, depth, maxBreadth) {\n  if (!event) {\n    return null;\n  }\n\n  const normalized = {\n    ...event,\n    ...(event.breadcrumbs && {\n      breadcrumbs: event.breadcrumbs.map(b => ({\n        ...b,\n        ...(b.data && {\n          data: normalize(b.data, depth, maxBreadth),\n        }),\n      })),\n    }),\n    ...(event.user && {\n      user: normalize(event.user, depth, maxBreadth),\n    }),\n    ...(event.contexts && {\n      contexts: normalize(event.contexts, depth, maxBreadth),\n    }),\n    ...(event.extra && {\n      extra: normalize(event.extra, depth, maxBreadth),\n    }),\n  };\n\n  // event.contexts.trace stores information about a Transaction. Similarly,\n  // event.spans[] stores information about child Spans. Given that a\n  // Transaction is conceptually a Span, normalization should apply to both\n  // Transactions and Spans consistently.\n  // For now the decision is to skip normalization of Transactions and Spans,\n  // so this block overwrites the normalized event to add back the original\n  // Transaction information prior to normalization.\n  if (event.contexts?.trace && normalized.contexts) {\n    normalized.contexts.trace = event.contexts.trace;\n\n    // event.contexts.trace.data may contain circular/dangerous data so we need to normalize it\n    if (event.contexts.trace.data) {\n      normalized.contexts.trace.data = normalize(event.contexts.trace.data, depth, maxBreadth);\n    }\n  }\n\n  // event.spans[].data may contain circular/dangerous data so we need to normalize it\n  if (event.spans) {\n    normalized.spans = event.spans.map(span => {\n      return {\n        ...span,\n        ...(span.data && {\n          data: normalize(span.data, depth, maxBreadth),\n        }),\n      };\n    });\n  }\n\n  // event.contexts.flags (FeatureFlagContext) stores context for our feature\n  // flag integrations. It has a greater nesting depth than our other typed\n  // Contexts, so we re-normalize with a fixed depth of 3 here. We do not want\n  // to skip this in case of conflicting, user-provided context.\n  if (event.contexts?.flags && normalized.contexts) {\n    normalized.contexts.flags = normalize(event.contexts.flags, 3, maxBreadth);\n  }\n\n  return normalized;\n}\n\nfunction getFinalScope(scope, captureContext) {\n  if (!captureContext) {\n    return scope;\n  }\n\n  const finalScope = scope ? scope.clone() : new Scope();\n  finalScope.update(captureContext);\n  return finalScope;\n}\n\n/**\n * Parse either an `EventHint` directly, or convert a `CaptureContext` to an `EventHint`.\n * This is used to allow to update method signatures that used to accept a `CaptureContext` but should now accept an `EventHint`.\n */\nfunction parseEventHintOrCaptureContext(\n  hint,\n) {\n  if (!hint) {\n    return undefined;\n  }\n\n  // If you pass a Scope or `() => Scope` as CaptureContext, we just return this as captureContext\n  if (hintIsScopeOrFunction(hint)) {\n    return { captureContext: hint };\n  }\n\n  if (hintIsScopeContext(hint)) {\n    return {\n      captureContext: hint,\n    };\n  }\n\n  return hint;\n}\n\nfunction hintIsScopeOrFunction(hint) {\n  return hint instanceof Scope || typeof hint === 'function';\n}\n\nconst captureContextKeys = [\n  'user',\n  'level',\n  'extra',\n  'contexts',\n  'tags',\n  'fingerprint',\n  'propagationContext',\n] ;\n\nfunction hintIsScopeContext(hint) {\n  return Object.keys(hint).some(key => captureContextKeys.includes(key ));\n}\n\nexport { applyClientOptions, applyDebugIds, applyDebugMeta, parseEventHintOrCaptureContext, prepareEvent };\n//# sourceMappingURL=prepareEvent.js.map\n","import { getCurrentScope, getClient, withIsolationScope, getIsolationScope } from './currentScopes.js';\nimport { DEBUG_BUILD } from './debug-build.js';\nimport { makeSession, updateSession, closeSession } from './session.js';\nimport { isThenable } from './utils/is.js';\nimport { logger } from './utils/logger.js';\nimport { uuid4 } from './utils/misc.js';\nimport { parseEventHintOrCaptureContext } from './utils/prepareEvent.js';\nimport { timestampInSeconds } from './utils/time.js';\nimport { GLOBAL_OBJ } from './utils/worldwide.js';\n\n/**\n * Captures an exception event and sends it to Sentry.\n *\n * @param exception The exception to capture.\n * @param hint Optional additional data to attach to the Sentry event.\n * @returns the id of the captured Sentry event.\n */\nfunction captureException(exception, hint) {\n  return getCurrentScope().captureException(exception, parseEventHintOrCaptureContext(hint));\n}\n\n/**\n * Captures a message event and sends it to Sentry.\n *\n * @param message The message to send to Sentry.\n * @param captureContext Define the level of the message or pass in additional data to attach to the message.\n * @returns the id of the captured message.\n */\nfunction captureMessage(message, captureContext) {\n  // This is necessary to provide explicit scopes upgrade, without changing the original\n  // arity of the `captureMessage(message, level)` method.\n  const level = typeof captureContext === 'string' ? captureContext : undefined;\n  const context = typeof captureContext !== 'string' ? { captureContext } : undefined;\n  return getCurrentScope().captureMessage(message, level, context);\n}\n\n/**\n * Captures a manually created event and sends it to Sentry.\n *\n * @param event The event to send to Sentry.\n * @param hint Optional additional data to attach to the Sentry event.\n * @returns the id of the captured event.\n */\nfunction captureEvent(event, hint) {\n  return getCurrentScope().captureEvent(event, hint);\n}\n\n/**\n * Sets context data with the given name.\n * @param name of the context\n * @param context Any kind of data. This data will be normalized.\n */\nfunction setContext(name, context) {\n  getIsolationScope().setContext(name, context);\n}\n\n/**\n * Set an object that will be merged sent as extra data with the event.\n * @param extras Extras object to merge into current context.\n */\nfunction setExtras(extras) {\n  getIsolationScope().setExtras(extras);\n}\n\n/**\n * Set key:value that will be sent as extra data with the event.\n * @param key String of extra\n * @param extra Any kind of data. This data will be normalized.\n */\nfunction setExtra(key, extra) {\n  getIsolationScope().setExtra(key, extra);\n}\n\n/**\n * Set an object that will be merged sent as tags data with the event.\n * @param tags Tags context object to merge into current context.\n */\nfunction setTags(tags) {\n  getIsolationScope().setTags(tags);\n}\n\n/**\n * Set key:value that will be sent as tags data with the event.\n *\n * Can also be used to unset a tag, by passing `undefined`.\n *\n * @param key String key of tag\n * @param value Value of tag\n */\nfunction setTag(key, value) {\n  getIsolationScope().setTag(key, value);\n}\n\n/**\n * Updates user context information for future events.\n *\n * @param user User context object to be set in the current context. Pass `null` to unset the user.\n */\nfunction setUser(user) {\n  getIsolationScope().setUser(user);\n}\n\n/**\n * The last error event id of the isolation scope.\n *\n * Warning: This function really returns the last recorded error event id on the current\n * isolation scope. If you call this function after handling a certain error and another error\n * is captured in between, the last one is returned instead of the one you might expect.\n * Also, ids of events that were never sent to Sentry (for example because\n * they were dropped in `beforeSend`) could be returned.\n *\n * @returns The last event id of the isolation scope.\n */\nfunction lastEventId() {\n  return getIsolationScope().lastEventId();\n}\n\n/**\n * Create a cron monitor check in and send it to Sentry.\n *\n * @param checkIn An object that describes a check in.\n * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n * to create a monitor automatically when sending a check in.\n */\nfunction captureCheckIn(checkIn, upsertMonitorConfig) {\n  const scope = getCurrentScope();\n  const client = getClient();\n  if (!client) {\n    DEBUG_BUILD && logger.warn('Cannot capture check-in. No client defined.');\n  } else if (!client.captureCheckIn) {\n    DEBUG_BUILD && logger.warn('Cannot capture check-in. Client does not support sending check-ins.');\n  } else {\n    return client.captureCheckIn(checkIn, upsertMonitorConfig, scope);\n  }\n\n  return uuid4();\n}\n\n/**\n * Wraps a callback with a cron monitor check in. The check in will be sent to Sentry when the callback finishes.\n *\n * @param monitorSlug The distinct slug of the monitor.\n * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n * to create a monitor automatically when sending a check in.\n */\nfunction withMonitor(\n  monitorSlug,\n  callback,\n  upsertMonitorConfig,\n) {\n  const checkInId = captureCheckIn({ monitorSlug, status: 'in_progress' }, upsertMonitorConfig);\n  const now = timestampInSeconds();\n\n  function finishCheckIn(status) {\n    captureCheckIn({ monitorSlug, status, checkInId, duration: timestampInSeconds() - now });\n  }\n\n  return withIsolationScope(() => {\n    let maybePromiseResult;\n    try {\n      maybePromiseResult = callback();\n    } catch (e) {\n      finishCheckIn('error');\n      throw e;\n    }\n\n    if (isThenable(maybePromiseResult)) {\n      Promise.resolve(maybePromiseResult).then(\n        () => {\n          finishCheckIn('ok');\n        },\n        e => {\n          finishCheckIn('error');\n          throw e;\n        },\n      );\n    } else {\n      finishCheckIn('ok');\n    }\n\n    return maybePromiseResult;\n  });\n}\n\n/**\n * Call `flush()` on the current client, if there is one. See {@link Client.flush}.\n *\n * @param timeout Maximum time in ms the client should wait to flush its event queue. Omitting this parameter will cause\n * the client to wait until all events are sent before resolving the promise.\n * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it\n * doesn't (or if there's no client defined).\n */\nasync function flush(timeout) {\n  const client = getClient();\n  if (client) {\n    return client.flush(timeout);\n  }\n  DEBUG_BUILD && logger.warn('Cannot flush events. No client defined.');\n  return Promise.resolve(false);\n}\n\n/**\n * Call `close()` on the current client, if there is one. See {@link Client.close}.\n *\n * @param timeout Maximum time in ms the client should wait to flush its event queue before shutting down. Omitting this\n * parameter will cause the client to wait until all events are sent before disabling itself.\n * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it\n * doesn't (or if there's no client defined).\n */\nasync function close(timeout) {\n  const client = getClient();\n  if (client) {\n    return client.close(timeout);\n  }\n  DEBUG_BUILD && logger.warn('Cannot flush events and disable SDK. No client defined.');\n  return Promise.resolve(false);\n}\n\n/**\n * Returns true if Sentry has been properly initialized.\n */\nfunction isInitialized() {\n  return !!getClient();\n}\n\n/** If the SDK is initialized & enabled. */\nfunction isEnabled() {\n  const client = getClient();\n  return client?.getOptions().enabled !== false && !!client?.getTransport();\n}\n\n/**\n * Add an event processor.\n * This will be added to the current isolation scope, ensuring any event that is processed in the current execution\n * context will have the processor applied.\n */\nfunction addEventProcessor(callback) {\n  getIsolationScope().addEventProcessor(callback);\n}\n\n/**\n * Start a session on the current isolation scope.\n *\n * @param context (optional) additional properties to be applied to the returned session object\n *\n * @returns the new active session\n */\nfunction startSession(context) {\n  const isolationScope = getIsolationScope();\n  const currentScope = getCurrentScope();\n\n  // Will fetch userAgent if called from browser sdk\n  const { userAgent } = GLOBAL_OBJ.navigator || {};\n\n  const session = makeSession({\n    user: currentScope.getUser() || isolationScope.getUser(),\n    ...(userAgent && { userAgent }),\n    ...context,\n  });\n\n  // End existing session if there's one\n  const currentSession = isolationScope.getSession();\n  if (currentSession?.status === 'ok') {\n    updateSession(currentSession, { status: 'exited' });\n  }\n\n  endSession();\n\n  // Afterwards we set the new session on the scope\n  isolationScope.setSession(session);\n\n  return session;\n}\n\n/**\n * End the session on the current isolation scope.\n */\nfunction endSession() {\n  const isolationScope = getIsolationScope();\n  const currentScope = getCurrentScope();\n\n  const session = currentScope.getSession() || isolationScope.getSession();\n  if (session) {\n    closeSession(session);\n  }\n  _sendSessionUpdate();\n\n  // the session is over; take it off of the scope\n  isolationScope.setSession();\n}\n\n/**\n * Sends the current Session on the scope\n */\nfunction _sendSessionUpdate() {\n  const isolationScope = getIsolationScope();\n  const client = getClient();\n  const session = isolationScope.getSession();\n  if (session && client) {\n    client.captureSession(session);\n  }\n}\n\n/**\n * Sends the current session on the scope to Sentry\n *\n * @param end If set the session will be marked as exited and removed from the scope.\n *            Defaults to `false`.\n */\nfunction captureSession(end = false) {\n  // both send the update and pull the session from the scope\n  if (end) {\n    endSession();\n    return;\n  }\n\n  // only send the update\n  _sendSessionUpdate();\n}\n\nexport { addEventProcessor, captureCheckIn, captureEvent, captureException, captureMessage, captureSession, close, endSession, flush, isEnabled, isInitialized, lastEventId, setContext, setExtra, setExtras, setTag, setTags, setUser, startSession, withMonitor };\n//# sourceMappingURL=exports.js.map\n"],"names":["DEBUG_BUILD","GLOBAL_OBJ","SDK_VERSION","getMainCarrier","getSentryCarrier","carrier","__SENTRY__","getGlobalSingleton","name","creator","obj","PREFIX","CONSOLE_LEVELS","originalConsoleMethods","consoleSandbox","callback","console","wrappedFuncs","wrappedLevels","level","originalConsoleMethod","makeLogger","enabled","logger","args","STACKTRACE_FRAME_LIMIT","UNKNOWN_FUNCTION","WEBPACK_ERROR_REGEXP","STRIP_FRAME_REGEXP","createStackParser","parsers","sortedParsers","a","b","p","stack","skipFirstLines","framesToPop","frames","lines","i","line","cleanedLine","parser","frame","stripSentryFramesAndReverse","stackParserFromStackParserOptions","stackParser","localStack","getLastStackFrame","arr","defaultFunctionName","getFunctionName","fn","getFramesFromEvent","event","exception","value","objectToString","isError","wat","isInstanceOf","isBuiltin","className","isErrorEvent","isDOMError","isDOMException","isString","isParameterizedString","isPrimitive","isPlainObject","isEvent","isElement","isRegExp","isThenable","isSyntheticEvent","base","isVueViewModel","isRequest","request","WINDOW","DEFAULT_MAX_STRING_LENGTH","htmlTreeAsString","elem","options","currentElem","MAX_TRAVERSE_HEIGHT","out","height","len","separator","sepLength","nextStr","keyAttrs","maxStringLength","_htmlElementAsString","el","keyAttrPairs","keyAttr","keyAttrPair","classes","allowedAttrs","k","attr","getLocationHref","getComponentName","truncate","str","max","safeJoin","input","delimiter","output","isMatchingPattern","pattern","requireExactStringMatch","stringMatchesSomePattern","testString","patterns","fill","source","replacementFactory","original","wrapped","markFunctionWrapped","addNonEnumerableProperty","proto","getOriginalFunction","func","convertToPlainObject","getOwnProperties","newObj","serializeEventTarget","target","extractedProps","property","extractExceptionKeysForMessage","maxLength","keys","firstKey","includedKeys","serialized","getCrypto","gbl","uuid4","crypto","getRandomByte","typedArray","c","getFirstException","getEventDescription","message","eventId","firstException","addExceptionTypeValue","type","values","addExceptionMechanism","newMechanism","defaultMechanism","currentMechanism","mergedData","checkOrSetAlreadyCaught","isAlreadyCaptured","ONE_SECOND_IN_MS","dateTimestampInSeconds","createUnixTimestampInSecondsFunc","performance","approxStartingTimeOrigin","timeOrigin","timestampInSeconds","cachedTimeOrigin","getBrowserTimeOrigin","threshold","performanceNow","dateNow","timeOriginDelta","timeOriginIsReliable","navigationStart","navigationStartDelta","navigationStartIsReliable","browserPerformanceTimeOrigin","makeSession","context","startingTime","session","sessionToJSON","updateSession","duration","closeSession","status","merge","initialObj","mergeObj","levels","key","generateTraceId","generateSpanId","SCOPE_SPAN_FIELD","_setSpanForScope","scope","span","_getSpanForScope","DEFAULT_MAX_BREADCRUMBS","Scope","newScope","client","lastEventId","user","tags","extras","extra","fingerprint","captureContext","scopeToMerge","scopeInstance","contexts","propagationContext","breadcrumb","maxBreadcrumbs","maxCrumbs","mergedBreadcrumb","attachment","newData","hint","syntheticException","getDefaultCurrentScope","getDefaultIsolationScope","AsyncContextStack","isolationScope","assignedScope","assignedIsolationScope","maybePromiseResult","e","res","getAsyncContextStack","registry","sentry","withScope","withSetScope","withIsolationScope","getStackAsyncContextStrategy","_isolationScope","getAsyncContextStrategy","getCurrentScope","getIsolationScope","getGlobalScope","rest","acs","getClient","getTraceContextFromScope","traceId","parentSpanId","propagationSpanId","traceContext","SEMANTIC_ATTRIBUTE_SENTRY_SOURCE","SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE","SEMANTIC_ATTRIBUTE_SENTRY_PREVIOUS_TRACE_SAMPLE_RATE","SEMANTIC_ATTRIBUTE_SENTRY_OP","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","SEMANTIC_ATTRIBUTE_PROFILE_ID","SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME","SPAN_STATUS_UNSET","SPAN_STATUS_OK","SCOPE_ON_START_SPAN_FIELD","ISOLATION_SCOPE_ON_START_SPAN_FIELD","getCapturedScopesOnSpan","SENTRY_BAGGAGE_KEY_PREFIX","SENTRY_BAGGAGE_KEY_PREFIX_REGEX","baggageHeaderToDynamicSamplingContext","baggageHeader","baggageObject","parseBaggageHeader","dynamicSamplingContext","acc","nonPrefixedKey","curr","currBaggageObject","baggageHeaderToObject","baggageEntry","keyOrValue","TRACE_FLAG_SAMPLED","hasShownSpanDropWarning","spanToTraceContext","spanId","trace_id","isRemote","parent_span_id","spanToJSON","span_id","convertSpanLinksForEnvelope","links","traceFlags","restContext","attributes","spanTimeInputToSeconds","ensureTimestampInSeconds","timestamp","spanIsSentrySpan","spanIsOpenTelemetrySdkTraceBaseSpan","startTime","endTime","getStatusMessage","castSpan","spanIsSampled","ROOT_SPAN_FIELD","getRootSpan","getActiveSpan","showSpanDropWarning","hasSpansEnabled","maybeOptions","DEFAULT_ENVIRONMENT","ORG_ID_REGEX","DSN_REGEX","isValidProtocol","protocol","dsnToString","dsn","withPassword","host","path","pass","port","projectId","publicKey","dsnFromString","match","lastPath","split","projectMatch","dsnFromComponents","components","validateDsn","component","extractOrgIdFromDsnHost","makeDsn","from","FROZEN_DSC_FIELD","getDynamicSamplingContextFromClient","public_key","org_id","dsc","getDynamicSamplingContextFromScope","getDynamicSamplingContextFromSpan","rootSpan","rootSpanJson","rootSpanAttributes","traceState","rootSpanSampleRate","applyLocalSampleRateToDsc","frozenDsc","traceStateDsc","dscOnTraceState","normalize","depth","maxProperties","visit","err","normalizeToSize","object","maxSize","normalized","jsonSize","memo","memoBuilder","memoize","unmemoize","stringified","stringifyValue","remainingDepth","valueWithToJSON","jsonValue","numAdded","visitable","visitKey","visitValue","objName","getConstructorName","prototype","utf8Length","inner","States","RESOLVED","REJECTED","resolvedSyncPromise","SyncPromise","resolve","rejectedSyncPromise","reason","_","reject","executor","onfulfilled","onrejected","result","val","onfinally","isRejected","cachedHandlers","handler","setResult","state","notifyEventProcessors","processors","index","processor","final","applyScopeDataToEvent","data","breadcrumbs","sdkProcessingMetadata","applyDataToEvent","applySpanToEvent","applyFingerprintToEvent","applyBreadcrumbsToEvent","applySdkMetadataToEvent","mergeScopeData","mergeData","eventProcessors","attachments","transactionName","mergeAndOverwriteScopeData","prop","mergeVal","mergedBreadcrumbs","parsedStackResults","lastKeysCount","cachedFilenameDebugIds","getFilenameToDebugIdMap","debugIdMap","debugIdKeys","stackKey","parsedStack","filename","debugId","getDebugImagesForResources","resource_paths","filenameDebugIdMap","images","prepareEvent","normalizeDepth","normalizeMaxBreadth","prepared","integrations","applyClientOptions","applyIntegrationsMetadata","applyDebugIds","finalScope","getFinalScope","clientEventProcessors","isolationData","finalScopeData","evt","applyDebugMeta","normalizeEvent","environment","release","dist","maxValueLength","debug_id","integrationNames","maxBreadth","captureException","captureEvent","setContext","setTag","addEventProcessor","startSession","currentScope","userAgent","currentSession","endSession","_sendSessionUpdate","captureSession","end"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36]}